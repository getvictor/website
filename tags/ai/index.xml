<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI on Victor on Software</title><link>https://victoronsoftware.com/tags/ai/</link><description>Recent content in AI on Victor on Software</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://victoronsoftware.com/tags/ai/index.xml" rel="self" type="application/rss+xml"/><item><title>Will AI agents replace software developers?</title><link>https://victoronsoftware.com/posts/will-ai-agents-replace-developers/</link><pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/will-ai-agents-replace-developers/</guid><description>&lt;img src="https://victoronsoftware.com/posts/will-ai-agents-replace-developers/ai-agents-replace-developers-headline.png" alt="Featured image of post Will AI agents replace software developers?" />&lt;p>&lt;strong>TL;DR:&lt;/strong> AI coding agents are becoming mainstream, but their impact is focused mainly on implementation and automated
testing. Productivity gains are real but capped, and engineers must still actively guide and supervise these tools.
Complete developer replacement is unlikely anytime soon.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#requirements-gathering" >Requirements gathering&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#design" >Design&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#implementation" >Implementation&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#testing" >Testing&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#deployment" >Deployment&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#maintenance" >Maintenance&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#ai-coding-agent-impact-across-the-sdlc" >AI coding agent impact across the SDLC&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#will-ai-coding-agents-replace-software-developers" >Will AI coding agents replace software developers?&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="introduction">&lt;a href="#introduction" class="header-anchor">&lt;/a>Introduction
&lt;/h2>&lt;p>AI is no longer just autocomplete. With AI coding agents, it is becoming a collaborator. But what happens when that
collaborator starts writing and testing entire chunks of your codebase? Will software engineers become managers of
fleets of AI agents, or will their jobs evolve in less dramatic ways?&lt;/p>
&lt;p>Our previous article covered the &lt;a class="link" href="../ai-for-software-developers/" >AI trends in the first half of 2025&lt;/a>. Using AI for
code completion and code generation was becoming mainstream. Today, in the second half of 2025, we can expect most
software developers to be using AI, off and on, for these tasks. But what about using AI coding agents to make
significant changes to the codebase, including automatically running and fixing tests? Recent surveys show that most
software engineers are NOT using AI agents. With AI code completion tools like GitHub Copilot being widely adopted
within about one year, we can reasonably assume that AI agents will likewise be widely adopted by the second half
of 2026. With that in mind, what will a typical engineer&amp;rsquo;s day look like in 2026?&lt;/p>
&lt;h3 id="ai-tools-adoption-timeline-in-software-development">&lt;a href="#ai-tools-adoption-timeline-in-software-development" class="header-anchor">&lt;/a>AI tools adoption timeline in software development
&lt;/h3>&lt;pre class="mermaid">
timeline
2022-2023 : GitHub Copilot Launch
: Early AI code completion
: Developer experimentation
2024 : Code completion mainstream
: ChatGPT for development
: Basic code generation
2025 : Advanced code generation
: AI debugging tools
: Early AI agents (experimental)
2026 : AI agents widely adopted
: Automated testing with AI
: AI code review assistants
2027+ : AI-native development workflows
: Advanced agent orchestration
: Full SDLC integration
&lt;/pre>
&lt;p>Let&amp;rsquo;s walk through the software development lifecycle (SDLC) and understand where these new AI coding agents can be
used. We will focus specifically on the new capabilities that AI coding agents bring, and not on the existing and
largely mainstream capabilities of AI code completion and chatbots.&lt;/p>
&lt;pre class="mermaid">
---
title: SDLC
---
graph LR
Requirements[Requirements gathering] --&amp;gt; Design[Design]
Design --&amp;gt; Implementation[Implementation]
Implementation --&amp;gt; Testing[Testing]
Testing --&amp;gt; Deployment[Deployment]
Deployment --&amp;gt; Maintenance[Maintenance]
%% Color coding based on AI agent impact level
%% Low impact - light blue
%% Medium impact - yellow/orange
%% High impact - green
classDef lowImpact fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000
classDef mediumImpact fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
classDef highImpact fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
class Requirements,Deployment lowImpact
class Design,Maintenance mediumImpact
class Implementation,Testing highImpact
&lt;/pre>
&lt;h2 id="requirements-gathering">&lt;a href="#requirements-gathering" class="header-anchor">&lt;/a>Requirements gathering
&lt;/h2>&lt;p>In requirements gathering, we need to figure out why we are adding a feature and what the feature is, at a high level.
We have two major sources of product features. The first one is a strategic feature that will open up new sources of
revenue for us. The second is a customer request, which we must build to keep our customers happy. A single feature
could be both of these.&lt;/p>
&lt;p>To understand the customer, we actually need to talk to the customer. Barring that, we could do market analysis to see
what similar features our competition has. ChatGPT can speed up this process by aggregating and explaining the
information. In this case, ChatGPT makes research more efficient, much like Google made research more efficient than
going to the library. But this is not a new AI use case. Product managers have been using AI to speed up their work for
years now.&lt;/p>
&lt;p>As far as figuring out what we&amp;rsquo;re building and why, AI coding agents may have little to add. That said, they may have
some use cases, such as writing a script to fetch and analyze data from a public API.&lt;/p>
&lt;p>&lt;em>Note:&lt;/em> Requirements gathering combines the planning and requirements analysis phases, assuming we use a fast-paced
Agile iterative process.&lt;/p>
&lt;h2 id="design">&lt;a href="#design" class="header-anchor">&lt;/a>Design
&lt;/h2>&lt;p>In the design phase, we get into the details of what we&amp;rsquo;re building. We specify the UI requirements, API changes,
integrations with other services, and other technical requirements.&lt;/p>
&lt;h3 id="spike-stories-and-proof-of-concepts-pocs">&lt;a href="#spike-stories-and-proof-of-concepts-pocs" class="header-anchor">&lt;/a>Spike stories and proof of concepts (POCs)
&lt;/h3>&lt;p>Often, there are enough uncertainties in the feature that software engineers must do a spike story or build a POC. A
spike story is an Agile user story to research a technical question. Spike stories uncover things like:&lt;/p>
&lt;ul>
&lt;li>Technical feasibility (e.g., can we use TPM to sign HTTP messages?)&lt;/li>
&lt;li>Implementation approach (e.g., should we use webhooks or polling?)&lt;/li>
&lt;li>Integration behavior (e.g., how does this 3rd party API handle pagination and errors?)&lt;/li>
&lt;li>Tool or library evaluation (e.g., does this 3rd party library provide all the features we need?)&lt;/li>
&lt;li>Unknown complexities or risk (e.g., will this actually work?)&lt;/li>
&lt;/ul>
&lt;p>In a spike story or POC, we often write quick throwaway code without other architectural considerations, such as
maintainability. And this is where AI coding agents can help. Theoretically, an AI coding agent can create a whole POC
with only a cursory review from the software developer. But this is an extreme case. In most cases, the work will be a
mix of coding, reviewing technical documentation, searching the web, and talking with ChatGPT.&lt;/p>
&lt;p>So, with the help of an AI coding agent, we could finish our spike story faster. If the work was timeboxed, the end
result should be higher quality.&lt;/p>
&lt;h3 id="final-design">&lt;a href="#final-design" class="header-anchor">&lt;/a>Final design
&lt;/h3>&lt;p>After the spike story, we still need to finish the design, providing all the technical specifications required for
estimation and implementation. These details include an understanding of how this feature interacts with all the other
parts of our application, such as:&lt;/p>
&lt;ul>
&lt;li>UI&lt;/li>
&lt;li>configuration&lt;/li>
&lt;li>authentication&lt;/li>
&lt;li>monitoring and logging&lt;/li>
&lt;li>error handling&lt;/li>
&lt;li>scalability and performance&lt;/li>
&lt;li>internationalization&lt;/li>
&lt;/ul>
&lt;p>Although some of these aspects are shared between features, we, as software developers, still need to consider and
investigate the new feature&amp;rsquo;s implications. AI coding agents are of little help here, besides providing boilerplate
requirements.&lt;/p>
&lt;h2 id="implementation">&lt;a href="#implementation" class="header-anchor">&lt;/a>Implementation
&lt;/h2>&lt;p>After the feature has been designed and estimated, it is time to get down to the work of coding. Can an AI agent do all
of this? Well, we may not be able to take the design and feed it to our agent. A product manager or another engineer may
have done the design, and this design may lack enough details for implementation. So we have to add details, like:&lt;/p>
&lt;ul>
&lt;li>Function names (e.g., &lt;code>sendEmailNotification&lt;/code>)&lt;/li>
&lt;li>Constant and enum names (e.g., &lt;code>RoleAdmin&lt;/code>)&lt;/li>
&lt;li>File and package structure (e.g., &lt;code>handlers/user.go&lt;/code>)&lt;/li>
&lt;li>Error handling strategy (e.g., wrap errors and add context)&lt;/li>
&lt;li>Interface design (e.g., create a new interface to simplify testing)&lt;/li>
&lt;li>Security considerations (e.g., validate inputs)&lt;/li>
&lt;/ul>
&lt;p>Yes, an AI coding agent may indeed come up with some of these on its own. However, we must consciously consider these to
ensure our codebase is maintainable, testable, scalable, and handles corner cases.&lt;/p>
&lt;p>So, once we know what we need to code, we can write a prompt to the AI coding agent and let it do its work. Today&amp;rsquo;s AI
coding agents are not very fast. In our experience, we ask an AI agent to do a chunk of work, and it completes it in
several minutes. Then we do a brief review of what it did and come back to it with corrections. Corrections often
include things like:&lt;/p>
&lt;ul>
&lt;li>Using the correct coding standards for our codebase&lt;/li>
&lt;li>Removing unneeded code (e.g., handling cases that we know cannot happen)&lt;/li>
&lt;li>Removing/merging duplicate code&lt;/li>
&lt;li>Using better names for functions/variables (e.g., don&amp;rsquo;t use &lt;code>err2&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>If we let the AI agent do a bigger chunk of work (30+ minutes), there is a greater chance that it will go off the rails,
and all the work must be redone. For example, an AI agent could decide to implement a third-party library itself because
it couldn&amp;rsquo;t figure out how to use the existing one.&lt;/p>
&lt;pre class="mermaid">
---
title: AI agent development workflow
---
flowchart TD
A[Developer writes prompt] --&amp;gt; B[AI agent codes&amp;lt;br/&amp;gt;3-5 minutes]
B --&amp;gt; C[Human reviews code]
C --&amp;gt; D{Code acceptable?}
D --&amp;gt;|No| E[Developer provides&amp;lt;br/&amp;gt;corrections]
E --&amp;gt; B
D --&amp;gt;|Yes| F[Final code review]
F --&amp;gt; G[Ask AI agent to review code]
G --&amp;gt; H[Human peer review]
H --&amp;gt; I[Ready for QA]
%% Styling
classDef humanTask fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000
classDef aiTask fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
classDef reviewTask fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
class A,C,E,F,H humanTask
class B,G aiTask
class D,I reviewTask
&lt;/pre>
&lt;p>Once we reach a good stopping point, we need to review all the code changes that we and our AI agent have made. Since
much of the code was autogenerated, we must take extra care to do a thorough review. The goal is to fully understand the
implementation so that we can speak about it as if we coded all of it ourselves.&lt;/p>
&lt;p>Once we have checked in the code or opened a PR, we can ask another AI agent to review it. With multiple LLMs and coding
agents out there, it is good practice to have one AI agent check the work of another AI agent for anything that we may
have missed. Unfortunately, this means wading through a few false positives. However, the end result is higher-quality
code that is ready for one of our peers to review.&lt;/p>
&lt;h3 id="multitasking-with-multiple-ai-agents">&lt;a href="#multitasking-with-multiple-ai-agents" class="header-anchor">&lt;/a>Multitasking with multiple AI agents
&lt;/h3>&lt;p>Some developers report using multiple AI agents to work on numerous projects simultaneously. In our workflow, this
approach is not practical. We know from behavioral science research that it takes a human up to 15 minutes to entirely
switch between different tasks because they must reload and recall all of the context associated with the new task into
their brain. So, if we switch between tasks every 5-10 minutes, the result is that we&amp;rsquo;re never deeply engaged with any
of these tasks, likely leading to lower quality software.&lt;/p>
&lt;p>Perhaps two AI coding agents can work on two tasks for the same feature. However, in this case, the two tasks must be
independent, which is more of an exception than the norm.&lt;/p>
&lt;p>Even if we decide to save some time by switching from AI agent coding to a longer task, such as a code review for one of
our peers, when we return to the agent, we will need to recall what we told the agent to do and what our expectations
were.&lt;/p>
&lt;h3 id="integration-with-the-rest-of-the-codebase">&lt;a href="#integration-with-the-rest-of-the-codebase" class="header-anchor">&lt;/a>Integration with the rest of the codebase
&lt;/h3>&lt;p>A lot of software development work involves hooking up the feature into the existing codebase. For example, we need to
create the new object and properly do dependency injection. These things often only take a few lines of code. Although
AI coding agents can do these integrations, it is often just as fast and more reliable to manually code these smaller
snippets.&lt;/p>
&lt;h3 id="full-stack-development">&lt;a href="#full-stack-development" class="header-anchor">&lt;/a>Full stack development
&lt;/h3>&lt;p>AI coding agents can help you write in a programming language you&amp;rsquo;re unfamiliar with. The agent will do the brunt work,
getting the syntax (mostly) right, and you can review the code to make sure it looks reasonable. This means software
developers can easily expand beyond their functional specialty into other languages and parts of the codebase.&lt;/p>
&lt;p>From an SDLC perspective, a single feature is now more likely to be assigned to a single developer instead of being
partitioned across backend/frontend or server/client boundaries. In this case, a single developer should be able to
finish a feature faster, without the handoffs and the issues they entail.&lt;/p>
&lt;p>Overall, AI coding agents can significantly help speed up the implementation phase. However, we must note that AI agent
effectiveness varies by task. Specifically, agents struggle with complex/niche designs and unfamiliar contexts.&lt;/p>
&lt;h2 id="testing">&lt;a href="#testing" class="header-anchor">&lt;/a>Testing
&lt;/h2>&lt;p>The two main testing areas are automated tests, including unit and integration tests, and manual tests.&lt;/p>
&lt;h3 id="automated-unit-tests">&lt;a href="#automated-unit-tests" class="header-anchor">&lt;/a>Automated (unit) tests
&lt;/h3>&lt;p>Writing tests has been a primary use case for generative AI over the past few years. So, given detailed instructions
regarding the scenarios to test, an AI coding agent should be able to write the test, run the test, and fix any issues.
The software developer will still need to review and adjust the tests. Some common problems with agent-generated tests
include:&lt;/p>
&lt;ul>
&lt;li>Not following project standards regarding the test helper methods being used (e.g., wrong HTTP client, wrong assert
method)&lt;/li>
&lt;li>Wordy and hard to maintain tests (e.g., not following a table test approach, not using subtests)&lt;/li>
&lt;li>Duplicated tests (e.g., testing a case that was covered elsewhere in the test suite)&lt;/li>
&lt;li>Using numbers in test variables instead of descriptive names (e.g., rsp1, err2)&lt;/li>
&lt;li>Not actually testing anything (e.g., hard-coding test expectations in the source implementation)&lt;/li>
&lt;/ul>
&lt;p>The AI agent may come up with some corner cases to test, but it cannot be relied on for full functional correctness.
Since the AI agent can see the implementation, it often bases its tests on what has been implemented. It lacks an
understanding of the intended requirements and, hence, what should be tested.&lt;/p>
&lt;h3 id="manual-tests">&lt;a href="#manual-tests" class="header-anchor">&lt;/a>Manual tests
&lt;/h3>&lt;p>Before handing over the implementation to the QA team, the software developer should review the test plan themselves and
perform all the manual tests. Any issues found can be candidates for additional automated tests.&lt;/p>
&lt;p>There is no AI agent today that can replace manual testers, but engineers can try to take advantage of AI to help in
some areas:&lt;/p>
&lt;ul>
&lt;li>Convert natural language to test steps&lt;/li>
&lt;li>Identify visual (UI) regressions&lt;/li>
&lt;li>Accessibility testing&lt;/li>
&lt;li>Auto-healing tests: updating tests when UI changes&lt;/li>
&lt;/ul>
&lt;p>So, for the testing phase, AI coding agents provide much help with creating and fixing automated tests, but not so much
with manual testing.&lt;/p>
&lt;h2 id="deployment">&lt;a href="#deployment" class="header-anchor">&lt;/a>Deployment
&lt;/h2>&lt;p>Before deploying the app to customers, engineers should do a release readiness check covering items like:&lt;/p>
&lt;ul>
&lt;li>All committed features implemented&lt;/li>
&lt;li>Testing and QA complete&lt;/li>
&lt;li>Security checks passed&lt;/li>
&lt;li>Load testing complete&lt;/li>
&lt;/ul>
&lt;p>After deployment, engineers should conduct smoke tests and health checks to ensure the app is working.&lt;/p>
&lt;p>In addition, deployment involves communication tasks, such as:&lt;/p>
&lt;ul>
&lt;li>demos, guides, FAQs&lt;/li>
&lt;li>release notes and changelogs&lt;/li>
&lt;/ul>
&lt;p>Generative AI is being used to generate some communication content. AI coding agents can provide little additional value
in the deployment phase.&lt;/p>
&lt;h2 id="maintenance">&lt;a href="#maintenance" class="header-anchor">&lt;/a>Maintenance
&lt;/h2>&lt;p>The maintenance phase of the software development lifecycle includes:&lt;/p>
&lt;ul>
&lt;li>Answering customer and internal questions&lt;/li>
&lt;li>Responding to alerts and incidents (e.g., investigating high CPU usage, resolving a failed background job)&lt;/li>
&lt;li>Reproducing and fixing customer-reported bugs&lt;/li>
&lt;/ul>
&lt;p>AI search tools have been helpful with searching the codebase and documentation to answer questions. Some upcoming tools
are trying to close the loop between production monitoring and source code fixes, and this is a great area to watch.
Reproducing bugs is still very much a manual process.&lt;/p>
&lt;p>Fixing bugs is an implementation task, so AI coding agents can help create the fix and a unit test. However, bug fixes
tend to be small in nature, with most of the software engineer&amp;rsquo;s time spent figuring out where the bug is and how best
to fix it.&lt;/p>
&lt;h2 id="ai-coding-agent-impact-across-the-sdlc">&lt;a href="#ai-coding-agent-impact-across-the-sdlc" class="header-anchor">&lt;/a>AI coding agent impact across the SDLC
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>SDLC Phase&lt;/th>
&lt;th>AI Agent Impact&lt;/th>
&lt;th>🔍 Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>📝 Requirements&lt;/td>
&lt;td>❌ Low&lt;/td>
&lt;td>Some research support, but little for strategic/product thinking&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🧠 Design&lt;/td>
&lt;td>⚠️ Low–Medium&lt;/td>
&lt;td>Help limited to spike stories and boilerplate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>💻 Implementation&lt;/td>
&lt;td>✅ High&lt;/td>
&lt;td>Most benefit seen here (code gen, agent pair programming)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🧪 Automated Testing&lt;/td>
&lt;td>✅ High&lt;/td>
&lt;td>Strong at generating/fixing tests, needs human oversight&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🧍 Manual Testing&lt;/td>
&lt;td>❌ Low&lt;/td>
&lt;td>Still mostly a human-driven process&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🚀 Deployment&lt;/td>
&lt;td>❌ Low&lt;/td>
&lt;td>Some help with writing release notes, limited technical role&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🔧 Maintenance&lt;/td>
&lt;td>⚠️ Medium&lt;/td>
&lt;td>Good at fixes; weak at reproducing or analyzing issues&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="risk-and-tradeoffs">&lt;a href="#risk-and-tradeoffs" class="header-anchor">&lt;/a>Risk and tradeoffs
&lt;/h2>&lt;p>While AI coding agents offer clear benefits, they also introduce new risks and tradeoffs that teams must actively
manage:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Shallow code understanding&lt;/strong>: Engineers may be tempted to rely on agents without fully understanding the generated
code. This erodes accountability and leads to slower debugging when issues arise.&lt;/li>
&lt;li>&lt;strong>Inconsistent quality&lt;/strong>: Agent-generated code can be verbose, redundant, or subtly incorrect. Without careful review,
these issues can slip into production.&lt;/li>
&lt;li>&lt;strong>Developer deskilling&lt;/strong>: Over-reliance on agents may reduce hands-on practice with fundamentals, particularly for
junior engineers who are still developing intuition.&lt;/li>
&lt;li>&lt;strong>Security and compliance&lt;/strong>: Agents can unknowingly introduce vulnerabilities or use unsafe patterns, especially when
integrating with third-party APIs or handling sensitive data.&lt;/li>
&lt;/ul>
&lt;p>In short, AI agents amplify output, but without discipline and oversight, they can amplify problems too. Teams must
treat agent-generated code with &lt;strong>greater&lt;/strong> rigor than human-written code.&lt;/p>
&lt;h2 id="will-ai-coding-agents-replace-software-developers">&lt;a href="#will-ai-coding-agents-replace-software-developers" class="header-anchor">&lt;/a>Will AI coding agents replace software developers?
&lt;/h2>&lt;p>Recent studies suggest that current AI tools improve productivity by 10% to 20%.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://arxiv.org/abs/2410.12944" target="_blank" rel="noopener"
>AI speeds up Google engineers by 21%&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://nypost.com/2025/03/14/business/jpmorgan-credits-coding-assistant-tool-for-boosting-engineers-efficiency/" target="_blank" rel="noopener"
>JPMorgan claims AI boosts efficiency by up to 20%&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.itpro.com/software/development/atlassian-says-ai-has-created-an-unexpected-paradox-for-software-developers-theyre-saving-over-10-hours-a-week-but-theyre-still-overworked-and-losing-an-equal-amount-of-time-due-to-organizational-inefficiencies" target="_blank" rel="noopener"
>Atlassian says AI is saving over 10 hours per week&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.reuters.com/business/ai-slows-down-some-experienced-software-developers-study-finds-2025-07-10" target="_blank" rel="noopener"
>AI slows down some developers&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>So, will the productivity improvements jump with AI coding agents becoming mainstream? Will one engineer be able to do
the work of a whole team?&lt;/p>
&lt;p>Looking at the whole software development process, we see that the most significant gains from AI coding agents are in
the implementation and automated testing phases. The consensus from studies and industry reports is that software
engineers spend only about 30% of their time writing code. The rest of the time is spent in the other phases of the
SDLC, as well as on other tasks such as:&lt;/p>
&lt;ul>
&lt;li>attending and preparing for meetings (e.g., planning, retros, 1:1s)&lt;/li>
&lt;li>mentoring, teaching, and continuous learning&lt;/li>
&lt;li>context switching and task juggling&lt;/li>
&lt;li>recruiting, interviewing, and candidate evaluation&lt;/li>
&lt;li>writing or reviewing internal documentation, ADRs, and RFCs&lt;/li>
&lt;li>developer advocacy, blogging, and community engagement&lt;/li>
&lt;li>travel for conferences, offsites, or customer visits&lt;/li>
&lt;li>improving tooling, automation, and developer environments&lt;/li>
&lt;/ul>
&lt;p>Even assuming AI agents completely automate coding tasks (30% of work), the maximum productivity gain would be 43%: if
70% of work remains unchanged, then 30% time savings translates to doing 1.43x the work. In other words, 7 people can
now do the work of 10 people. This is far from the popular claims that AI will replace all software engineers.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/will-ai-agents-replace-developers/productivity-gain.svg">
&lt;/figure>
&lt;p>In summary, AI in general and AI coding agents in particular should continue to have a noticeable impact on software
developer productivity. However, developers&amp;rsquo; work is complex and varied, and AI can only provide efficiency improvements
and not wholesale replacement. AI coding agents won&amp;rsquo;t replace developers, but developers who know how to use them will
replace those who don&amp;rsquo;t.&lt;/p>
&lt;h2 id="further-reading">&lt;a href="#further-reading" class="header-anchor">&lt;/a>Further reading
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;a class="link" href="../ai-for-software-developers/" >How to use AI for software development (2025)&lt;/a>&lt;/strong>&lt;br>
&lt;em>What every software engineer needs to know about AI right now: code completion, generation, and AI agents.&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;a class="link" href="../introducing-mcp/" >Introducing MCP: Lessons from building an AI-driven server&lt;/a>&lt;/strong>&lt;br>
&lt;em>How we taught an AI agent to use our product with MCP.&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="watch-us-discuss-whether-ai-agents-can-replace-software-developers">&lt;a href="#watch-us-discuss-whether-ai-agents-can-replace-software-developers" class="header-anchor">&lt;/a>Watch us discuss whether AI agents can replace software developers
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/fdBxpWXajSE"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item><item><title>Introducing MCP: Lessons from building an AI-driven server</title><link>https://victoronsoftware.com/posts/introducing-mcp/</link><pubDate>Thu, 08 May 2025 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/introducing-mcp/</guid><description>&lt;img src="https://victoronsoftware.com/posts/introducing-mcp/introducing-mcp-headline.png" alt="Featured image of post Introducing MCP: Lessons from building an AI-driven server" />&lt;p>Recently, we developed a proof of concept using an MCP(Model Context Protocol) server to control
&lt;a class="link" href="https://fleetdm.com/" target="_blank" rel="noopener"
>Fleet&amp;rsquo;s device management server&lt;/a>. This server made a successful
&lt;a class="link" href="https://youtu.be/eKoOvT-fr2I" target="_blank" rel="noopener"
>demo video&lt;/a>. The takeaways from the video were:&lt;/p>
&lt;ul>
&lt;li>🧠 Natural language understanding — no commands to memorize&lt;/li>
&lt;li>🤖 Actionable context awareness — the AI remembers what you&amp;rsquo;re asking about&lt;/li>
&lt;li>🔗 Tool selection and orchestration — chooses the proper action automatically&lt;/li>
&lt;/ul>
&lt;p>In this article, we&amp;rsquo;ll talk about our process for integrating our API with agentic AI, mistakes made, and lessons
learned.&lt;/p>
&lt;h2 id="what-is-mcp-and-why-do-i-need-one">&lt;a href="#what-is-mcp-and-why-do-i-need-one" class="header-anchor">&lt;/a>What is MCP, and why do I need one?
&lt;/h2>&lt;p>MCP (Model Context Protocol) is a client-server framework that enables AI agents to interact with your tools and APIs
through natural language. MCP was introduced by &lt;a class="link" href="https://www.anthropic.com/news/model-context-protocol" target="_blank" rel="noopener"
>Anthropic&lt;/a> in
November 2024. Its primary use case was to use local tools available on your local machine, such as databases.&lt;/p>
&lt;p>But, some may ask why we need another framework—aren&amp;rsquo;t AI agents good enough to use those tools directly? Yes, it is
true that by providing AI agents with instructions on how to use an arbitrary tool, the AI agent should be able to use
it. However, MCP standardizes this approach. Thus, an MCP server created for one tool can be reused by many developers
and by many AI agents.&lt;/p>
&lt;p>Instead of telling your AI agent about every tool, imagine that the AI agent has access to a library of MCP servers that
it can install whenever you want to &amp;ldquo;teach&amp;rdquo; it about a tool. Think of MCP as an intelligent middleware that allows AI
agents to understand and use your system&amp;rsquo;s capabilities appropriately. With MCP, the AI can dynamically learn and adapt
to your system&amp;rsquo;s interface.&lt;/p>
&lt;h3 id="the-mcp-protocol">&lt;a href="#the-mcp-protocol" class="header-anchor">&lt;/a>The MCP protocol
&lt;/h3>&lt;p>The MCP protocol consists of several key components:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Tools: These are functions or actions that can be performed. Tools are defined by name, description, and parameters
they accept. They represent the capabilities your system provides to AI agents.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Resources: These are data objects that tools can operate on. Resources have properties and relationships with other
resources. For example, a &lt;code>User&lt;/code> resource might have properties like name and email.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Prompts: These are reusable prompt templates and workflows intended to standardize common LLM interactions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Schema Definition: The protocol uses a schema to describe available tools and resources, making it easy for AI agents
to understand possible actions.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The main distinction between tools and resources is that tools are actions (verbs), while resources are objects (nouns)
on which these actions may operate. For example, a &lt;code>createUser&lt;/code> tool might operate on a &lt;code>User&lt;/code> resource. In practice,
however, you can create a &lt;code>User&lt;/code> tool that returns a user and not worry about associating it with a resource. The
semantics of tools are simpler than those of resources, so it might be faster only to use tools if your goal is to get
something working quickly.&lt;/p>
&lt;h2 id="building-an-mcp-server-with-agentic-ai">&lt;a href="#building-an-mcp-server-with-agentic-ai" class="header-anchor">&lt;/a>Building an MCP server with agentic AI
&lt;/h2>&lt;p>Our biggest mistake was asking our AI agent (&lt;a class="link" href="https://roocode.com/" target="_blank" rel="noopener"
>Roo Code&lt;/a>) to build an MCP server without fully
understanding the MCP details ourselves. To summarize, this process was not successful.&lt;/p>
&lt;p>MCP has SDKs available for multiple languages. We decided to build our MCP server with TypeScript. Our AI agent pulled
in the right &lt;a class="link" href="https://github.com/modelcontextprotocol/typescript-sdk" target="_blank" rel="noopener"
>TypeScript MCP SDK&lt;/a>. However, it couldn&amp;rsquo;t get the
compile to work, so it removed the SDK and implemented the MCP protocol from scratch. We allowed our agent to proceed
since we didn&amp;rsquo;t know any better.&lt;/p>
&lt;p>After implementing a basic tool, we couldn&amp;rsquo;t get the MCP server to work reliably. It worked using &lt;code>curl&lt;/code>, but the
&lt;a class="link" href="https://github.com/modelcontextprotocol/inspector" target="_blank" rel="noopener"
>MCP inspector&lt;/a> debug tool couldn&amp;rsquo;t connect to our MCP server.
Another mistake we made was not telling the AI agent to use liberal debug messages up front, which would have sped up
the debug effort.&lt;/p>
&lt;p>After letting our AI agent waste our API credits for too long, we told it to rewrite the code using the TypeScript SDK.
We copied and pasted the examples that our agent could reference. After that, things went smoothly.&lt;/p>
&lt;p>Another engineer suggested that using the Python SDK would have been more effective and required less handholding.&lt;/p>
&lt;p>Our proof of concept &lt;a class="link" href="https://github.com/getvictor/fleet-mcp" target="_blank" rel="noopener"
>MCP server for Fleet API&lt;/a> is on GitHub. Here&amp;rsquo;s a code
example for the &lt;code>install_software&lt;/code> tool:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Register the install_software tool
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">mcpServer&lt;/span>.&lt;span style="color:#a6e22e">tool&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;install_software&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Install software on a host managed by Fleet&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">host_id&lt;/span>: &lt;span style="color:#66d9ef">z.string&lt;/span>().&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Required. The host ID&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">software_id&lt;/span>: &lt;span style="color:#66d9ef">z.string&lt;/span>().&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Required. The software title ID&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> (&lt;span style="color:#a6e22e">params&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">host_id&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>; &lt;span style="color:#a6e22e">software_id&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> }) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Installing software ID &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">params&lt;/span>.&lt;span style="color:#a6e22e">software_id&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> on host ID &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">params&lt;/span>.&lt;span style="color:#a6e22e">host_id&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`/api/v1/fleet/hosts/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">params&lt;/span>.&lt;span style="color:#a6e22e">host_id&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/software/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">params&lt;/span>.&lt;span style="color:#a6e22e">software_id&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/install`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">axiosInstance&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#a6e22e">url&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Fleet API install request successful&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;text&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">text&lt;/span>: &lt;span style="color:#66d9ef">JSON.stringify&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (&lt;span style="color:#a6e22e">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Fleet API error:&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">error&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">code&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;internal_error&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`Fleet API error: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">error&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> Error &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">error.message&lt;/span> : &lt;span style="color:#66d9ef">String&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see above, the code is pretty straightforward. We&amp;rsquo;re simply wrapping an existing API call with an MCP tool.&lt;/p>
&lt;h3 id="overall-impressions">&lt;a href="#overall-impressions" class="header-anchor">&lt;/a>Overall impressions
&lt;/h3>&lt;p>AI agent interactions with our MCP server are complex to test and challenging to debug. First, as an MCP server
developer, you must be familiar with AI agents, MCP protocol, and the tool interface you&amp;rsquo;re trying to use. For example,
in one case, the AI agent didn&amp;rsquo;t use the proper parameter to call the tool and came up with wrong conclusions. Since we
are dealing with AI, it is hard to tell how often such mistakes will happen and also hard to fix or prevent them. Also,
we don&amp;rsquo;t know exactly how customers may use the MCP server, so the QA test space is quite large.&lt;/p>
&lt;p>Our product already has an API, a CLI, and a UI interface. Adding MCP to the mix feels hard to justify—are customers
going to use all these ways to interact with our product? For a small product team, investing in MCP support might not
make sense until a customer is ready to pay for it.&lt;/p>
&lt;h2 id="further-reading">&lt;a href="#further-reading" class="header-anchor">&lt;/a>Further reading
&lt;/h2>&lt;ul>
&lt;li>We recently covered &lt;a class="link" href="../will-ai-agents-replace-developers/" >the broader implications of AI agents in software development&lt;/a>.&lt;/li>
&lt;li>Previously, we discussed &lt;a class="link" href="../ai-for-software-developers/" >what every software engineer needs to know about AI right now&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="watch-how-we-taught-an-ai-agent-to-use-our-product-with-mcp">&lt;a href="#watch-how-we-taught-an-ai-agent-to-use-our-product-with-mcp" class="header-anchor">&lt;/a>Watch how we taught an AI agent to use our product with MCP
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/1RLh3SpfytQ"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item><item><title>How to use AI for software development (2025)</title><link>https://victoronsoftware.com/posts/ai-for-software-developers/</link><pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/ai-for-software-developers/</guid><description>&lt;img src="https://victoronsoftware.com/posts/ai-for-software-developers/ai-building-software.png" alt="Featured image of post How to use AI for software development (2025)" />&lt;p>The AI landscape is changing rapidly. A new tool seems to come out weekly, or we hear about a breakthrough. As a
software engineer, it is hard to keep up with all the latest developments and even harder to figure out what is relevant
to your day-to-day work. Many tech leaders claim that AI is helping them achieve greater engineering velocity, improving
the quality of their code, and enhancing the engineering experience, to name a few. But how can you leverage AI to
improve your work as a software engineer? And, most importantly, what is the most effective way to use AI right now?&lt;/p>
&lt;p>We have followed AI since the early 2000s, when Jeff Hawkins published
&lt;a class="link" href="https://en.wikipedia.org/wiki/On_Intelligence" target="_blank" rel="noopener"
>On Intelligence&lt;/a>. AI has come a long way since then. Today, most
software engineers can benefit from some AI.&lt;/p>
&lt;p>The top AI use cases for software engineers are:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#code-completion" >Code completion&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#code-generation" >Code generation&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#summarizing-or-explaining-code" >Summarizing or explaining code&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#agentic-coding" >Agentic coding&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Some software developers have other use cases for AI, such as image generation, but this article will focus on the above
ones.&lt;/p>
&lt;h2 id="code-completion">&lt;a href="#code-completion" class="header-anchor">&lt;/a>Code completion
&lt;/h2>&lt;p>The original GitHub Copilot popularized AI code completion. It is a tool that can be integrated into your IDE and can
perform multi-line code completions. GitHub Copilot and similar tools have been extremely popular with software
developers. We found AI code completion extremely helpful, even though it occasionally generates function signatures and
other code that is not quite right.&lt;/p>
&lt;p>For example, after creating the &lt;code>PubSubMessage&lt;/code> struct in our code, Copilot recommended the &lt;code>PubSubMessageAttributes&lt;/code>
struct. Opening the completions window shows other multi-line suggestions.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/ai-for-software-developers/copilot-example.png">&lt;figcaption>
&lt;h4>GitHub Copilot code completion example&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>The code completion is not only for software code. We used it for documentation, such as writing a user guide for a new
feature. AI is most useful for boilerplate introductory content. However, beware that some search engines may be able to
detect the use of AI in your documentation and reduce your search ranking.&lt;/p>
&lt;h2 id="code-generation">&lt;a href="#code-generation" class="header-anchor">&lt;/a>Code generation
&lt;/h2>&lt;p>Code generation is similar to code completion, but the desired result is a complete function or code block. Typically,
engineers use a chat interface such as ChatGPT and provide it with a description of the desired function. Providing a
detailed description along with inputs and outputs is key to getting the best results.&lt;/p>
&lt;p>For example, given the following prompt:&lt;/p>
&lt;blockquote>
&lt;p>Write a Golang function that takes path.URL, makes a GET request to that URL, parses the JSON response, and returns
the &amp;ldquo;attributes&amp;rdquo; and &amp;ldquo;data&amp;rdquo; fields of the response.&lt;/p>&lt;/blockquote>
&lt;p>ChatGPT o1 model generated the following code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// FetchAttributesAndData makes a GET request to the provided URL, parses&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// the JSON response, and returns the &amp;#34;attributes&amp;#34; and &amp;#34;data&amp;#34; fields.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">FetchAttributesAndData&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>) (&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">interface&lt;/span>{}, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resp&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Get&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// You may also check resp.StatusCode for error handling if desired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusOK&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unexpected status code: %d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Define a struct to capture the JSON structure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Attributes&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">interface&lt;/span>{} &lt;span style="color:#e6db74">`json:&amp;#34;attributes&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Data&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{} &lt;span style="color:#e6db74">`json:&amp;#34;data&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">NewDecoder&lt;/span>(&lt;span style="color:#a6e22e">resp&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>).&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">result&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span>.&lt;span style="color:#a6e22e">Attributes&lt;/span>, &lt;span style="color:#a6e22e">result&lt;/span>.&lt;span style="color:#a6e22e">Data&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ChatGPT also provided some documentation and a usage example.&lt;/p>
&lt;p>Previously, software engineers would accomplish this task by searching Google or StackOverflow for similar code
snippets. Now, they can use AI chatbots to generate this code. This approach is most useful when you need to generate
code that&amp;rsquo;s not your area of expertise.&lt;/p>
&lt;p>Some programming languages have dedicated AI code-generation tools. For example, you can create Go functions and
packages online with &lt;a class="link" href="https://sketch.dev/" target="_blank" rel="noopener"
>sketch.dev&lt;/a>.&lt;/p>
&lt;h2 id="summarizing-or-explaining-code">&lt;a href="#summarizing-or-explaining-code" class="header-anchor">&lt;/a>Summarizing or explaining code
&lt;/h2>&lt;p>When software engineers work on a large codebase, they often need to understand code written by other engineers, some of
whom may have left the company, and they may also need to find a specific piece of code in the codebase.&lt;/p>
&lt;p>AI can help by reading the codebase and adding it to its context. This is an example of Retrieval-Augmented Generation
(RAG), where AI combines its general knowledge with the specific context of the codebase.&lt;/p>
&lt;p>To understand the codebase, the AI tool needs to add the code to its context or to index the codebase. Then, the tool
can use a combination of AI and deterministic search to find the relevant code. Below is an example of a question we
asked &lt;a class="link" href="https://www.cursor.com/" target="_blank" rel="noopener"
>Cursor&lt;/a> IDE about our codebase:&lt;/p>
&lt;blockquote>
&lt;p>In which Go files is macOS disk encryption code located?&lt;/p>&lt;/blockquote>
&lt;p>Cursor provided a list of files and additional information on the top hits.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/ai-for-software-developers/cursor-example.png">&lt;figcaption>
&lt;h4>Cursor codebase search example&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Codebase-wide queries are a great way to find information yourself before asking the broader team. They are also a
decent way to learn the codebase.&lt;/p>
&lt;h2 id="agentic-coding">&lt;a href="#agentic-coding" class="header-anchor">&lt;/a>Agentic coding
&lt;/h2>&lt;p>Agentic coding refers to using an AI agent to write code and perform tasks on your behalf. Using agents is a more
advanced use case, requiring you to know the AI tools, processes, and LLMs well. A good AI agent can:&lt;/p>
&lt;ul>
&lt;li>Write code, including creating and moving files&lt;/li>
&lt;li>Write and run tests, including Browser UI tests&lt;/li>
&lt;li>Write, read, and follow documentation&lt;/li>
&lt;li>Do terminal operations such as installing applications&lt;/li>
&lt;li>Do Git operations such as pushing&lt;/li>
&lt;li>Connect to other servers with SSH&lt;/li>
&lt;/ul>
&lt;p>Currently, the top agentic coding tools are:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/RooVetGit/Roo-Code" target="_blank" rel="noopener"
>Roo Code&lt;/a> (VSCode plugin)&lt;/li>
&lt;li>&lt;a class="link" href="https://cline.bot/" target="_blank" rel="noopener"
>Cline&lt;/a> (VSCode plugin)&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cursor.com/" target="_blank" rel="noopener"
>Cursor&lt;/a> (IDE built on top of VSCode)&lt;/li>
&lt;/ul>
&lt;p>There are many other tools and platforms available. GitHub Copilot also announced Agent mode, which is available in
preview as of this writing. JetBrains has announced &lt;a class="link" href="https://www.jetbrains.com/junie/" target="_blank" rel="noopener"
>Junie&lt;/a>, which is only available
via the Early Access Program.&lt;/p>
&lt;p>As the agentic coding tools are still in their early stages, changing rapidly, and require a lot of handholding, it is
reasonable to wait 6 to 12 months before revisiting them.&lt;/p>
&lt;h3 id="ai-coding-agent-workflows">&lt;a href="#ai-coding-agent-workflows" class="header-anchor">&lt;/a>AI coding agent workflows
&lt;/h3>&lt;p>The following are some workflow suggestions for using an AI coding agent to create a small application.&lt;/p>
&lt;p>First, start with some context regarding what you want to build. Create a README or a plan outlining how you want to
structure the application and the steps to implement it. You can use another general-purse AI, such as ChatGPT, to help
you create the high-level plan.&lt;/p>
&lt;p>For example, we asked ChatGPT to create a high-level plan with the following prompt:&lt;/p>
&lt;blockquote>
&lt;p>We want to create a mock Google Android Management API server using an AI agent. The server is written in Golang and
will interact with our MDM solution during testing. It should hold the state for enterprises, profiles, and fake
devices enrolled in it. The server should have a mock PubSub webhook that will push notifications regarding ENROLLMENT
and STATUS_REPORTs. Please create a plan that another AI agent can implement in several steps.&lt;/p>&lt;/blockquote>
&lt;p>Next, ask the AI agent to read the plan, update it, and create a more detailed plan. It may make sense to break the plan
into smaller parts and treat each part as a separate project. In effect, you act as the AI agent&amp;rsquo;s project manager.&lt;/p>
&lt;p>Make sure to have documentation and have the AI agent update it regularly. In addition to the README, you can have API
specs, secrets, and other documentation files.&lt;/p>
&lt;p>Tell the AI agent to initialize a git repo, create the project structure, and start implementing the plan. For each
step, ask the AI agent to create tests. After each step, ask the AI agent to update the documentation and commit the
changes. This way, you can easily rollback if the AI agent gets stuck or goes off the rails.&lt;/p>
&lt;p>Try to be as precise as possible in your prompts.&lt;/p>
&lt;p>When adding a new feature, you can start a new session with the AI agent and ask it to read all the documentation. This
will &amp;ldquo;initialize&amp;rdquo; the AI agent with the project context.&lt;/p>
&lt;p>Work in small development iterations with your AI agent.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/ai-for-software-developers/ai-agent-workflow.png">&lt;figcaption>
&lt;h4>AI agent workflow&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Learn about your AI agent&amp;rsquo;s specific features to level up your skills. Often, there are ways to provide context to the
agent or give special meaning to certain words or files.&lt;/p>
&lt;p>At some point, you may want to take over the maintenance of the code from the AI agent. For example, check the code into
your main repository and maintain it as any other human-written code.&lt;/p>
&lt;h3 id="ai-coding-agent-issues">&lt;a href="#ai-coding-agent-issues" class="header-anchor">&lt;/a>AI coding agent issues
&lt;/h3>&lt;p>The main issue with AI coding agents is that they make mistakes. If you spot their mistake, you can tell them about it,
and they will generally correct it. However, if you can&amp;rsquo;t spot their mistake, the agent may end up in a loop where it
keeps trying to fix the issue, but your application still doesn&amp;rsquo;t work. That is why it is essential to work in small
iterations where you can roll back and start over.&lt;/p>
&lt;p>The other issue is that AI agents are slow. Often, they need to take several steps to make progress, and the human is
left waiting—being there just in case they need help or go off track. Theoretically, a single human could manage
multiple AI agents, but in practice, it is hard for people to frequently switch between multiple cognitively demanding
tasks.&lt;/p>
&lt;h2 id="further-reading">&lt;a href="#further-reading" class="header-anchor">&lt;/a>Further reading
&lt;/h2>&lt;ul>
&lt;li>For a deeper look at AI agents&amp;rsquo; impact on software development, check out &lt;a class="link" href="../will-ai-agents-replace-developers/" >Will AI agents replace software developers?&lt;/a>&lt;/li>
&lt;li>We just published &lt;a class="link" href="../introducing-mcp/" >our lessons learned from building an AI-driven MCP server&lt;/a>.&lt;/li>
&lt;li>We recently discussed
&lt;a class="link" href="../scaling-codebase-evolutionary-architecture/" >how to scale your codebase with incremental design&lt;/a>.&lt;/li>
&lt;li>We also wrote about &lt;a class="link" href="../readable-code/" >the importance of readable code&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="watch-how-to-use-ai-for-software-development">&lt;a href="#watch-how-to-use-ai-for-software-development" class="header-anchor">&lt;/a>Watch how to use AI for software development
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/PVdqwcwc2_o"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item></channel></rss>