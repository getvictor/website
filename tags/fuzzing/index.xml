<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fuzzing on Victor on Software</title><link>https://victoronsoftware.com/tags/fuzzing/</link><description>Recent content in Fuzzing on Victor on Software</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://victoronsoftware.com/tags/fuzzing/index.xml" rel="self" type="application/rss+xml"/><item><title>Fuzz testing in Go</title><link>https://victoronsoftware.com/posts/fuzz-testing-with-go/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/fuzz-testing-with-go/</guid><description>&lt;img src="https://victoronsoftware.com/posts/fuzz-testing-with-go/fuzz.png" alt="Featured image of post Fuzz testing in Go" />&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/4emTXow54F4"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>Fuzz testing is a software automated testing technique where random inputs are provided to the software under test. My background is in
hardware verification, which uses sophisticated methodologies for pseudorandom testing, so I wanted to see what the Go library had to offer
out of the box.&lt;/p>
&lt;p>A &lt;a class="link" href="https://go.dev/doc/security/fuzz" target="_blank" rel="noopener"
>Go fuzz test&lt;/a> can run as:&lt;/p>
&lt;ul>
&lt;li>a normal unit test&lt;/li>
&lt;li>a test with fuzzing&lt;/li>
&lt;/ul>
&lt;p>A fuzz test is written similarly to a normal unit test in a *&lt;strong>_test.go&lt;/strong> file, with the following changes. It must have a &lt;strong>Fuzz&lt;/strong> prefix
and use the &lt;strong>testing.F&lt;/strong> struct instead of the usual &lt;strong>testing.T&lt;/strong> struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">FuzzSample&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">F&lt;/span>) {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here is a workflow for using fuzz testing. First, you create a fuzz test. Then, you run it with fuzzing to automatically find failing corner
cases and make any fixes. Thirdly, you include the test and the corner cases in your continuous integration testing suite.&lt;/p>
&lt;h2 id="create-a-fuzz-test">&lt;a href="#create-a-fuzz-test" class="header-anchor">&lt;/a>Create a fuzz test
&lt;/h2>&lt;p>When creating a fuzz test, you should provide a corpus of initial seed inputs. These are the inputs the test will use before applying
randomization. Add the seed corpus with the &lt;strong>Add&lt;/strong> method. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">tc&lt;/span>.&lt;span style="color:#a6e22e">Num&lt;/span>, &lt;span style="color:#a6e22e">tc&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(uint8(&lt;span style="color:#ae81ff">0&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The inputs to the &lt;strong>Add&lt;/strong> method indicate which types will be fuzzed, and these types must match the subsequent call to the &lt;strong>Fuzz&lt;/strong> method:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Fuzz&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>, &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The fuzz test can randomize any number of inputs, as long as they are one of the supported types.&lt;/p>
&lt;h2 id="run-the-test-with-fuzzing">&lt;a href="#run-the-test-with-fuzzing" class="header-anchor">&lt;/a>Run the test with fuzzing
&lt;/h2>&lt;p>To run the test with fuzzing, use the &lt;strong>-fuzz&lt;/strong> switch, like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go test -fuzz FuzzSample
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The test will continuously run on all your CPUs until it fails, or you kill it:&lt;/p>
&lt;pre tabindex="0">&lt;code>=== RUN FuzzSample
fuzz: elapsed: 0s, gathering baseline coverage: 0/11 completed
fuzz: elapsed: 0s, gathering baseline coverage: 11/11 completed, now fuzzing with 12 workers
fuzz: elapsed: 3s, execs: 432199 (144036/sec), new interesting: 0 (total: 11)
fuzz: elapsed: 6s, execs: 871147 (146328/sec), new interesting: 0 (total: 11)
&lt;/code>&lt;/pre>&lt;p>A sample failure:&lt;/p>
&lt;pre tabindex="0">&lt;code>failure while testing seed corpus entry: FuzzSample/49232526a5eabbdc
fuzz: elapsed: 1s, gathering baseline coverage: 10/11 completed
--- FAIL: FuzzSample (1.03s)
--- FAIL: FuzzSample (0.00s)
fuzz_test.go:21: Found 0
&lt;/code>&lt;/pre>&lt;p>The failures are automatically added to the seed corpus. The seed corpus includes the initial inputs that were added with the &lt;strong>Add&lt;/strong> method as
well as any new fails. These new seed corpus files are automatically created in the &lt;strong>testdata/fuzz/Fuzz&lt;/strong>* directory. Sample contents of one
such file:&lt;/p>
&lt;pre tabindex="0">&lt;code>go test fuzz v1
byte(&amp;#39;\x01&amp;#39;)
string(&amp;#34;0a0000&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>Adding the failure to the seed corpus means that the failing case will always run when this test is run again as a unit test or with
fuzzing.&lt;/p>
&lt;p>Now, you must fix the failing test and continue the loop of fuzzing and fixing.&lt;/p>
&lt;h2 id="include-the-test-in-continuous-integration">&lt;a href="#include-the-test-in-continuous-integration" class="header-anchor">&lt;/a>Include the test in continuous integration
&lt;/h2>&lt;p>When checking in the test to your repository, you must either include the &lt;strong>testdata/fuzz/Fuzz&lt;/strong>* files or convert those files into individual
&lt;strong>Add&lt;/strong> method calls in your test. Once the test is checked in, all the inputs in the seed corpus will run as part of the standard Go unit test
flow.&lt;/p>
&lt;h2 id="initial-impressions">&lt;a href="#initial-impressions" class="header-anchor">&lt;/a>Initial impressions
&lt;/h2>&lt;p>Fuzz testing appears to be a good approach to help the development of small functions with limited scope. The library documentation mentions
the following about the function under test:&lt;/p>
&lt;blockquote>
&lt;p>This function should be fast and deterministic, and its behavior should not depend on shared state.&lt;/p>
&lt;/blockquote>
&lt;p>I plan to give fuzzing a try the next time I develop such a function. I will share the results on this blog.&lt;/p>
&lt;h2 id="concerns-and-issues">&lt;a href="#concerns-and-issues" class="header-anchor">&lt;/a>Concerns and Issues
&lt;/h2>&lt;p>Native fuzzing support was added to Go in 1.18 and seems like a good initial approach. However, it feels limited in features and usability.
The types of functions, fast and deterministic, that fuzzing is intended for are generally not very interesting when testing real
applications. They are good examples for students learning how to code. However, more interesting testing scenarios include:&lt;/p>
&lt;ul>
&lt;li>Functions accessing remote resources in parallel, such as APIs or databases&lt;/li>
&lt;li>Functions with asynchronous code&lt;/li>
&lt;/ul>
&lt;p>Secondly, the fuzzing library does not provide a good way to guide the randomization of inputs and does not give feedback about the input
state space already covered. It does provide line coverage information, but that doesn&amp;rsquo;t help for unknown corner cases.&lt;/p>
&lt;p>If one of my inputs is intended to be a percentage, then I want most of the fuzzing to concentrate on the legal range of 0-100, as opposed
to all numbers. This lack of constraints becomes a problem when adding additional inputs to the fuzzing function, as the available state
space of inputs expands exponentially. If the state space of inputs is huge, there is no guarantee that fuzzing accomplished its goal of
finding all corner cases, leaving the developer with a false sense of confidence in their code.&lt;/p>
&lt;p>Lastly, the fuzz test is hard to maintain. The seed corpus is stored in files without any context regarding what corner case each seed is
hitting. Software engineers unfamiliar with fuzz testing will find this extremely confusing. If the fuzz test needs to be extended in the
future with additional inputs or different types, the old seed corpus will become useless. It will be worse than useless &amp;ndash; the test will
not run, and the developer unfamiliar with fuzz testing will not have a clear idea why.&lt;/p>
&lt;pre>&lt;code>fuzz_test.go:16: wrong number of values in corpus entry: 2, want 3
&lt;/code>&lt;/pre>
&lt;p>That said, understanding the fuzz testing limitation, Iâ€™m willing to try fuzz testing for more interesting test cases, such as database
accesses. I will report my findings in a future post.&lt;/p>
&lt;p>GitHub gist:
&lt;script src="https://gist.github.com/getvictor/24baadcc9cf08e7d7a6028ad54ff2aba.js">&lt;/script>
&lt;/p></description></item></channel></rss>