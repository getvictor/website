<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cyber Security on Victor on Software</title><link>https://victoronsoftware.com/tags/cyber-security/</link><description>Recent content in Cyber Security on Victor on Software</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://victoronsoftware.com/tags/cyber-security/index.xml" rel="self" type="application/rss+xml"/><item><title>Mutual TLS (mTLS): building a client using the system keystore</title><link>https://victoronsoftware.com/posts/mtls/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/mtls/</guid><description>&lt;img src="https://victoronsoftware.com/posts/mtls/mtls-handshake.png" alt="Featured image of post Mutual TLS (mTLS): building a client using the system keystore" />&lt;p>We recently completed a series of articles on mutual TLS (mTLS). In this series, we covered the basics of mTLS, how to use macOS keychain and Windows certificate store, and how to build an mTLS Go client. Our goal was to show you how to use mTLS in your applications and securely store your mTLS certificates and keys without exposing them to the filesystem.&lt;/p>
&lt;p>Here is a summary of the articles in the series:&lt;/p>
&lt;h3 id="mutual-tls-intro-and-hands-on-examplemtls-hello-world">&lt;a href="#mutual-tls-intro-and-hands-on-examplemtls-hello-world" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-hello-world" >Mutual TLS intro and hands-on example&lt;/a>
&lt;/h3>&lt;p>An introduction to mTLS and a hands-on example of using an mTLS client to connect to an mTLS server.&lt;/p>
&lt;h3 id="using-mtls-with-the-macos-keychainmtls-with-apple-keychain">&lt;a href="#using-mtls-with-the-macos-keychainmtls-with-apple-keychain" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-with-apple-keychain" >Using mTLS with the macOS keychain&lt;/a>
&lt;/h3>&lt;p>A guide on how to use the macOS system keystore to store your mTLS certificates and keys. We connect to an mTLS server with applications that use the macOS system keychain to find the mTLS certificates.&lt;/p>
&lt;h3 id="create-an-mtls-go-clientmtls-go-client">&lt;a href="#create-an-mtls-go-clientmtls-go-client" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-go-client" >Create an mTLS Go client&lt;/a>
&lt;/h3>&lt;p>We create a standard mTLS client in Go using the &lt;code>crypto/tls&lt;/code> library. This client loads the client certificate and private key from the filesystem.&lt;/p>
&lt;h3 id="add-a-custom-certificate-signer-to-the-mtls-go-clientmtls-go-custom-signer">&lt;a href="#add-a-custom-certificate-signer-to-the-mtls-go-clientmtls-go-custom-signer" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-go-custom-signer" >Add a custom certificate signer to the mTLS Go client&lt;/a>
&lt;/h3>&lt;p>We implement a custom &lt;code>crypto.Signer&lt;/code> to sign a client certificate during the mTLS handshake. Thus, we are a step closer to removing our client certificate and private key from the filesystem.&lt;/p>
&lt;h3 id="a-complete-mtls-go-client-using-the-macos-keychainmtls-go-client-using-apple-keychain">&lt;a href="#a-complete-mtls-go-client-using-the-macos-keychainmtls-go-client-using-apple-keychain" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-go-client-using-apple-keychain" >A complete mTLS Go client using the macOS keychain&lt;/a>
&lt;/h3>&lt;p>In this article, we continue the previous article by connecting our custom signer to the macOS keychain using CGO and Apple APIs.&lt;/p>
&lt;h3 id="using-mtls-with-the-windows-system-keystoremtls-with-windows">&lt;a href="#using-mtls-with-the-windows-system-keystoremtls-with-windows" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-with-windows" >Using mTLS with the Windows system keystore&lt;/a>
&lt;/h3>&lt;p>Switching to Windows, we learn how to use the Windows system keystore to store your mTLS certificates and keys. We connect to an mTLS server with applications that use the Windows system keystore to find the mTLS certificates.&lt;/p>
&lt;h3 id="create-an-mtls-go-client-using-the-windows-certificate-storemtls-go-client-windows-certificate-store">&lt;a href="#create-an-mtls-go-client-using-the-windows-certificate-storemtls-go-client-windows-certificate-store" class="header-anchor">&lt;/a>&lt;a class="link" href="../mtls-go-client-windows-certificate-store" >Create an mTLS Go client using the Windows certificate store&lt;/a>
&lt;/h3>&lt;p>Using the software pattern from the previous articles on the macOS keychain, we build an mTLS client in Go integrated with the Windows certificate store to store the mTLS certificates and keys.&lt;/p>
&lt;h3 id="mutual-tls-mtls-building-a-client-using-the-system-keystore-video-playlist">&lt;a href="#mutual-tls-mtls-building-a-client-using-the-system-keystore-video-playlist" class="header-anchor">&lt;/a>Mutual TLS (mTLS): building a client using the system keystore video playlist
&lt;/h3>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/videoseries?list=PLr-TrdMhEklRF4lQ_bIH0WJTUiY8ldc0W" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Mutual TLS (mTLS) with Windows certificate store</title><link>https://victoronsoftware.com/posts/mtls-with-windows/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/mtls-with-windows/</guid><description>&lt;img src="https://victoronsoftware.com/posts/mtls-with-windows/mtls-edge.png" alt="Featured image of post Mutual TLS (mTLS) with Windows certificate store" />&lt;p>&lt;em>This article is part of a series on &lt;a class="link" href="../mtls" >mTLS&lt;/a>. Check out the previous articles:&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../mtls-with-apple-keychain" >mTLS with macOS keychain&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../mtls-go-client" >mTLS Go client&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../mtls-go-custom-signer" >mTLS Go client with custom certificate signer&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../mtls-go-client-using-apple-keychain" >mTLS Go client using macOS keychain&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="why-use-windows-certificate-store">&lt;a href="#why-use-windows-certificate-store" class="header-anchor">&lt;/a>Why use Windows certificate store?
&lt;/h2>&lt;p>In our previous articles, we introduced mTLS and demonstrated how to use mTLS client certificates and keys. Keeping the mTLS client private key on the filesystem is insecure and not recommended. In the &lt;a class="link" href="../mtls-go-client-using-apple-keychain" >mTLS Go client using macOS keychain&lt;/a>, we demonstrated achieving greater mTLS security with macOS keychain. In this article, we start exploring how to achieve the same level of protection with Windows certificate store.&lt;/p>
&lt;p>The Windows certificate store is a secure location to store certificates and keys. Many applications, such as Edge and Powershell use it. The Windows certificate store is an excellent place to store mTLS client certificates and keys.&lt;/p>
&lt;p>The Windows certificate stores have two types:&lt;/p>
&lt;ul>
&lt;li>User certificate store: Certificates and keys are stored for the current user, local to a user account.&lt;/li>
&lt;li>Local machine certificate store: Certificates and keys are stored for all users on the computer.&lt;/li>
&lt;/ul>
&lt;p>We will store our client mTLS certificate in the user certificate store and the other certificates in the local machine certificate store.&lt;/p>
&lt;h2 id="generating-mtls-certificates-and-keys">&lt;a href="#generating-mtls-certificates-and-keys" class="header-anchor">&lt;/a>Generating mTLS certificates and keys
&lt;/h2>&lt;p>We will use the following Powershell script to generate the mTLS certificates and keys. &lt;a class="link" href="https://www.openssl.org/" target="_blank" rel="noopener"
>OpenSSL&lt;/a> must be installed on your computer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>New-Item -ItemType Directory -Force certs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Private keys for CAs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/server-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/client-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate CA certificates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/server-ca.key -out certs/server-ca.crt -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testServerCA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/client-ca.key -out certs/client-ca.crt -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testClientCA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate a certificate signing request&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> -nodes -keyout certs/server.key -out certs/server.req -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testServerTLS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span> -nodes -keyout certs/client.key -out certs/client.req -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testClientTLS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Have the CA sign the certificate requests and output the certificates.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/server.req -days &lt;span style="color:#ae81ff">398&lt;/span> -CA certs/server-ca.crt -CAkey certs/server-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/server.crt -extfile localhost.ext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/client.req -days &lt;span style="color:#ae81ff">398&lt;/span> -CA certs/client-ca.crt -CAkey certs/client-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/client.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Create PFX file for importing to certificate store&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl pkcs12 -export -out certs\client.pfx -inkey certs\client.key -in certs\client.crt -passout pass&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Clean up&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Remove-Item certs/server.req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Remove-Item certs/client.req
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The maximum validity period for a TLS certificate is 398 days.&lt;/p>
&lt;p>The &lt;code>localhost.ext&lt;/code> file is used to specify the subject alternative name (SAN) for the server certificate. The &lt;code>localhost.ext&lt;/code> file contains the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>[alt_names]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS.1 = localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS.2 = myhost
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can access the server using either &lt;code>localhost&lt;/code> or &lt;code>myhost&lt;/code> names.&lt;/p>
&lt;p>The above script generates the following files:&lt;/p>
&lt;ul>
&lt;li>&lt;code>certs/server-ca.crt&lt;/code>: Server CA certificate&lt;/li>
&lt;li>&lt;code>certs/server-ca.key&lt;/code>: Server CA private key&lt;/li>
&lt;li>&lt;code>certs/client-ca.crt&lt;/code>: Client CA certificate&lt;/li>
&lt;li>&lt;code>certs/client-ca.key&lt;/code>: Client CA private key&lt;/li>
&lt;li>&lt;code>certs/server.crt&lt;/code>: Server certificate&lt;/li>
&lt;li>&lt;code>certs/server.key&lt;/code>: Server private key&lt;/li>
&lt;li>&lt;code>certs/client.crt&lt;/code>: Client certificate&lt;/li>
&lt;li>&lt;code>certs/client.key&lt;/code>: Client private key&lt;/li>
&lt;li>&lt;code>certs/client.pfx&lt;/code>: Client certificate and private key in PFX format, needed for importing into the Windows certificate store&lt;/li>
&lt;/ul>
&lt;h2 id="importing-the-client-certificate-and-key-into-the-windows-certificate-store">&lt;a href="#importing-the-client-certificate-and-key-into-the-windows-certificate-store" class="header-anchor">&lt;/a>Importing the client certificate and key into the Windows certificate store
&lt;/h2>&lt;p>We will import the client certificate and key into the user certificate store using the following powershell script.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the server CA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Import-Certificate -FilePath &lt;span style="color:#e6db74">&amp;#34;certs\server-ca.crt&amp;#34;&lt;/span> -CertStoreLocation Cert&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>\LocalMachine\Root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the client CA so that client TLS certificates can be verified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Import-Certificate -FilePath &lt;span style="color:#e6db74">&amp;#34;certs\client-ca.crt&amp;#34;&lt;/span> -CertStoreLocation Cert&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>\LocalMachine\Root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the client TLS certificate and key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Import-PfxCertificate -FilePath &lt;span style="color:#e6db74">&amp;#34;certs\client.pfx&amp;#34;&lt;/span> -CertStoreLocation Cert&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>\CurrentUser\My
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The command result should be similar to the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span> PSParentPath: Microsoft.PowerShell.Security\Certificate::LocalMachine\Root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Thumbprint Subject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------- -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0A31BF3C48A3D98A91A2F63B5BD286818311A707 CN=testServerCA, OU=Your Unit, O=Your Organization, L=Austin, S=Texas, C=US
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7F7E5612F3A90B9EB246762358251F98911A9D1A CN=testClientCA, OU=Your Unit, O=Your Organization, L=Austin, S=Texas, C=US
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PSParentPath: Microsoft.PowerShell.Security\Certificate::CurrentUser\My
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Thumbprint Subject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------- -------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>E2EBB991E3849E32E934D8465FAE42787D34C9ED CN=testClientTLS, OU=Your Unit, O=Your Organization, L=Austin, S=Texas, C=US
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>By default, the private key is marked as non-exportable. A user or an application cannot export the private key from the certificate store. They can only access the private key via Windows APIs. Using a non-exportable private key is the recommended security approach. You can use the &lt;code>-Exportable&lt;/code> parameter if you need to export the private key.&lt;/p>
&lt;h2 id="verifying-imported-certificates-and-keys">&lt;a href="#verifying-imported-certificates-and-keys" class="header-anchor">&lt;/a>Verifying imported certificates and keys
&lt;/h2>&lt;p>As an extra step, we can verify that the certificates and keys exist in the Windows certificate store. We can use the &lt;code>certlm&lt;/code> Local Machine Certificate Manager GUI, &lt;code>certmgr&lt;/code> User Certificate Manager GUI, or the &lt;code>Get-ChildItem&lt;/code> powershell command.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Get-ChildItem -Path Cert&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>\LocalMachine\Root |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Where-Object{$_.Subject &lt;span style="color:#f92672">-match&lt;/span> &lt;span style="color:#e6db74">&amp;#39;testServerCA&amp;#39;&lt;/span>} |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Test-Certificate -Policy SSL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Get-ChildItem -Path Cert&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>\CurrentUser\My | Where-Object{$_.Subject &lt;span style="color:#f92672">-match&lt;/span> &lt;span style="color:#e6db74">&amp;#39;testClientTLS&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="running-the-mtls-server">&lt;a href="#running-the-mtls-server" class="header-anchor">&lt;/a>Running the mTLS server
&lt;/h2>&lt;p>We will use the same &lt;code>docker-compose.yml&lt;/code> file from the &lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a> article. The &lt;code>docker-compose.yml&lt;/code> file starts two nginx servers:&lt;/p>
&lt;ul>
&lt;li>https://&amp;lt;your_host&amp;gt;:8888 for TLS&lt;/li>
&lt;li>https://&amp;lt;your_host&amp;gt;:8889 for mTLS&lt;/li>
&lt;/ul>
&lt;p>We can run Docker on WSL (Windows Subsystem for Linux) or another machine. We will run it on a different machine, so we need to copy the &lt;code>certs&lt;/code> directory to the machine running Docker. When running the server on a different machine, we must update the &lt;code>C:\Windows\System32\drivers\etc\hosts&lt;/code> file to point to the other machine.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>10.0.0.5 myhost
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="connecting-to-the-tls-and-mtls-servers-with-clients">&lt;a href="#connecting-to-the-tls-and-mtls-servers-with-clients" class="header-anchor">&lt;/a>Connecting to the TLS and mTLS servers with clients
&lt;/h2>&lt;p>Because we added the server CA to the root certificate store, we can now access the TLS server without any additional flags:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//myhost&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">8888&lt;/span>/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>StatusCode : 200
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StatusDescription : OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content : TLS Hello World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RawContent : HTTP/1.1 200 OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Connection: keep-alive
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Accept-Ranges: bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Content-Length: 17
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Content-Type: text/plain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date: Sun, 03 Mar 2024 17:28:29 GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ETag: &amp;#34;65b29c19-11&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Last-Modified: Thu, 25 Jan 2024 1...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Forms : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Headers : {[Connection, keep-alive], [Accept-Ranges, bytes], [Content-Length, 17], [Content-Type, text/plain]...}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Images : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputFields : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Links : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ParsedHtml : System.__ComObject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RawContentLength : 17
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, we cannot access the mTLS server directly.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//myhost&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">8889&lt;/span>/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The client attempted the TLS handshake, but the server rejected the connection because the client did not provide a certificate. Result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>Invoke-WebRequest : 400 Bad Request
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No required SSL certificate was sent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nginx/1.25.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>At line:1 char:1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ Invoke-WebRequest -Uri https://myhost:8889/hello-world.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + CategoryInfo : InvalidOperation: (System.Net.HttpWebRequest:HttpWebRequest) [Invoke-WebRequest], WebException
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> + FullyQualifiedErrorId : WebCmdletWebResponseException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can, however, provide the client certificate thumbprint to access the mTLS server. We saw the thumbprint of the client certificate earlier when we imported it into the Windows certificate store.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Invoke-WebRequest -Uri https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//myhost&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">8889&lt;/span>/hello-world.txt -CertificateThumbprint E2EBB991E3849E32E934D8465FAE42787D34C9ED
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>StatusCode : 200
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StatusDescription : OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Content : mTLS Hello World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RawContent : HTTP/1.1 200 OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Connection: keep-alive
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Accept-Ranges: bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Content-Length: 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Content-Type: text/plain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date: Sun, 03 Mar 2024 17:31:55 GMT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ETag: &amp;#34;65b29c19-12&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Last-Modified: Thu, 25 Jan 2024 1...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Forms : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Headers : {[Connection, keep-alive], [Accept-Ranges, bytes], [Content-Length, 18], [Content-Type, text/plain]...}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Images : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputFields : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Links : {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ParsedHtml : System.__ComObject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RawContentLength : 18
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Edge browser can access the mTLS server. We can verify this by opening the following URL:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span style="display:flex;">&lt;span>https://myhost:8889/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We see the following popup:&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/mtls-with-windows/mtls-edge.png"
alt="Edge mTLS popup">&lt;figcaption>
&lt;p>Edge mTLS popup&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>We can click &lt;strong>OK&lt;/strong> to connect to the mTLS server. Future connections will not show the popup and will automatically use the client certificate.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> Here is a helpful link that may resolve issues trying to use mTLS client certificates on Windows 10: &lt;a class="link" href="https://superuser.com/questions/1181163/unable-to-use-client-certificates-in-chrome-or-ie-on-windows-10" target="_blank" rel="noopener"
>https://superuser.com/questions/1181163/unable-to-use-client-certificates-in-chrome-or-ie-on-windows-10&lt;/a>&lt;/p>
&lt;h2 id="example-code-on-github">&lt;a href="#example-code-on-github" class="header-anchor">&lt;/a>Example code on Github
&lt;/h2>&lt;p>The example code is available on GitHub at &lt;a class="link" href="https://github.com/getvictor/mtls/tree/master/mtls-with-windows" target="_blank" rel="noopener"
>https://github.com/getvictor/mtls/tree/master/mtls-with-windows&lt;/a>&lt;/p>
&lt;h2 id="creating-our-own-windows-mtls-client">&lt;a href="#creating-our-own-windows-mtls-client" class="header-anchor">&lt;/a>Creating our own Windows mTLS client
&lt;/h2>&lt;p>In the following article, we will &lt;a class="link" href="../mtls-go-client-windows-certificate-store" >create a custom Windows mTLS client using the Windows certificate store&lt;/a>.&lt;/p>
&lt;h2 id="mtls-with-windows-certificate-store-video">&lt;a href="#mtls-with-windows-certificate-store-video" class="header-anchor">&lt;/a>mTLS with Windows certificate store video
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/GuubP7vir1g"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item><item><title>Mutual TLS (mTLS) with macOS keychain</title><link>https://victoronsoftware.com/posts/mtls-with-apple-keychain/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/mtls-with-apple-keychain/</guid><description>&lt;img src="https://victoronsoftware.com/posts/mtls-with-apple-keychain/mtls-safari.png" alt="Featured image of post Mutual TLS (mTLS) with macOS keychain" />&lt;p>&lt;em>This article is part of a series on &lt;a class="link" href="../mtls" >mTLS&lt;/a>. Check out the previous article: &lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a>.&lt;/em>&lt;/p>
&lt;h2 id="securing-mtls-certificates-and-keys">&lt;a href="#securing-mtls-certificates-and-keys" class="header-anchor">&lt;/a>Securing mTLS certificates and keys
&lt;/h2>&lt;p>In the &lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a> article, we generated mTLS certificates and keys for the client and the server. We also created two certificate authorities (CAs) and signed the client and server certificates with their respective CAs. We ended up with the following files:&lt;/p>
&lt;ul>
&lt;li>server CA: &lt;code>certs/server-ca.crt&lt;/code>&lt;/li>
&lt;li>server CA private key: &lt;code>certs/server-ca.key&lt;/code>&lt;/li>
&lt;li>TLS certificate for localhost server: &lt;code>certs/server.crt&lt;/code>&lt;/li>
&lt;li>server TLS certificate private key: &lt;code>certs/server.key&lt;/code>&lt;/li>
&lt;li>client CA: &lt;code>certs/client-ca.crt&lt;/code>&lt;/li>
&lt;li>client CA private key: &lt;code>certs/client-ca.key&lt;/code>&lt;/li>
&lt;li>TLS certificate for client: &lt;code>certs/client.crt&lt;/code>&lt;/li>
&lt;li>client TLS certificate private key: &lt;code>certs/client.key&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>In a real-world scenario, we would need to secure these files. The server CA private key and the client CA private key are the most important files to secure. If an attacker gets access to these files, they can create new certificates and impersonate the server or the client. These two files should be secured in a dedicated secure storage.&lt;/p>
&lt;p>The server will need access to the client CA, the server TLS certificate, and the server TLS certificate private key. The server TLS certificate private key is the most important to secure out of these three files.&lt;/p>
&lt;p>The client will need access to the server CA, the client TLS certificate, and the client TLS certificate private key. We can use the macOS keychain to secure these files. In a future article, we will show how to secure these on Windows with certificate stores.&lt;/p>
&lt;h2 id="apples-macos-keychain">&lt;a href="#apples-macos-keychain" class="header-anchor">&lt;/a>Apple&amp;rsquo;s macOS keychain
&lt;/h2>&lt;p>As I&amp;rsquo;ve written in &lt;a class="link" href="../inspecting-keychain-files-on-macos" >inspecting keychain files on macOS&lt;/a>, keychains are the macOS&amp;rsquo;s method to track and protect secure information such as passwords, private keys, and certificates.&lt;/p>
&lt;p>The system keychain is located at &lt;code>/Library/Keychains/System.keychain&lt;/code>. It contains the root certificates and other certificates. The login keychain is located at &lt;code>/Users/&amp;lt;username&amp;gt;/Library/Keychains/login.keychain-db&lt;/code>. It contains the user&amp;rsquo;s certificates and private keys. In this example, we will use the system keychain, which all users on the system can access.&lt;/p>
&lt;h2 id="generating-mtls-certificates-and-keys">&lt;a href="#generating-mtls-certificates-and-keys" class="header-anchor">&lt;/a>Generating mTLS certificates and keys
&lt;/h2>&lt;p>We will use the following script to generate the mTLS certificates and keys. It resembles the script from the &lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a> article.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This script generates certificates and keys needed for mTLS.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p certs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Private keys for CAs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/server-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/client-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate CA certificates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/server-ca.key -out certs/server-ca.crt -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testServerCA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/client-ca.key -out certs/client-ca.crt -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testClientCA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate a certificate signing request&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa:2048 -nodes -keyout certs/server.key -out certs/server.req -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testServerTLS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa:2048 -nodes -keyout certs/client.key -out certs/client.req -subj &lt;span style="color:#e6db74">&amp;#34;/C=US/ST=Texas/L=Austin/O=Your Organization/OU=Your Unit/CN=testClientTLS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Have the CA sign the certificate requests and output the certificates.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/server.req -days &lt;span style="color:#ae81ff">398&lt;/span> -CA certs/server-ca.crt -CAkey certs/server-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/server.crt -extfile localhost.ext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/client.req -days &lt;span style="color:#ae81ff">398&lt;/span> -CA certs/client-ca.crt -CAkey certs/client-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/client.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Clean up&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm certs/server.req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm certs/client.req
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The maximum validity period for a TLS certificate is 398 days. Apple will reject certificates with a more extended validity period.&lt;/p>
&lt;h2 id="importing-client-mtls-certificates-and-keys-into-the-macos-keychain">&lt;a href="#importing-client-mtls-certificates-and-keys-into-the-macos-keychain" class="header-anchor">&lt;/a>Importing client mTLS certificates and keys into the macOS keychain
&lt;/h2>&lt;p>We will import the client mTLS certificates and keys into the macOS keychain using the following script. The script uses the &lt;a class="link" href="https://ss64.com/mac/security.html" target="_blank" rel="noopener"
>security&lt;/a> command line tool. Accessing the system keychain must be run as root (&lt;code>sudo&lt;/code>).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This script imports mTLS certificates and keys into the Apple Keychain.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the server CA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain certs/server-ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the client CA so that client TLS certificates can be verified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain certs/client-ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Import the client TLS certificate and key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>security import certs/client.crt -k /Library/Keychains/System.keychain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>security import certs/client.key -k /Library/Keychains/System.keychain -x -T /usr/bin/curl -T /Applications/Safari.app -T &lt;span style="color:#e6db74">&amp;#39;/Applications/Google Chrome.app&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>-x&lt;/code> option marks the imported key as non-extractable. No application or user can view the private key once it is imported. The private key can only be used indirectly via Apple&amp;rsquo;s APIs.&lt;/p>
&lt;p>The &lt;code>-T&lt;/code> option specifies the applications that can access the key. Additional applications may be added later to the access control list.&lt;/p>
&lt;h2 id="verifying-imported-certificates-and-keys">&lt;a href="#verifying-imported-certificates-and-keys" class="header-anchor">&lt;/a>Verifying imported certificates and keys
&lt;/h2>&lt;p>As an extra step, we can verify the client and server certificates before using them in an application.&lt;/p>
&lt;p>We can verify the server certificate by running the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>security verify-cert -c certs/server.crt -p ssl -s localhost -k /Library/Keychains/System.keychain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The output should include:&lt;/p>
&lt;pre tabindex="0">&lt;code>...certificate verification successful.
&lt;/code>&lt;/pre>&lt;p>The Apple keychain automatically combines the certificate and the private key into an identity. We can verify the client identity by running the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>security find-identity -p ssl-client /Library/Keychains/System.keychain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The list of identities should include:&lt;/p>
&lt;pre tabindex="0">&lt;code>Policy: SSL (client)
Matching identities
1) B307B90CCD374080E74F1B15AF602B35A75D8401 &amp;#34;testClientTLS&amp;#34;
1 identities found
Valid identities only
1) B307B90CCD374080E74F1B15AF602B35A75D8401 &amp;#34;testClientTLS&amp;#34;
1 valid identities found
&lt;/code>&lt;/pre>&lt;p>macOS can validate the identity because we also imported the client CA into the system keychain.&lt;/p>
&lt;h2 id="running-the-mtls-server">&lt;a href="#running-the-mtls-server" class="header-anchor">&lt;/a>Running the mTLS server
&lt;/h2>&lt;p>As in the &lt;a class="link" href="../mtls-hello-world" >mTLS Hello World&lt;/a> article, we will use &lt;code>docker compose up&lt;/code> to start two nginx servers:&lt;/p>
&lt;ul>
&lt;li>https://localhost:8888 for TLS&lt;/li>
&lt;li>https://localhost:8889 for mTLS&lt;/li>
&lt;/ul>
&lt;h2 id="connecting-to-the-tls-and-mtls-servers-with-clients">&lt;a href="#connecting-to-the-tls-and-mtls-servers-with-clients" class="header-anchor">&lt;/a>Connecting to the TLS and mTLS servers with clients
&lt;/h2>&lt;p>Because the server CA was added to the system keychain, curl can now access the TLS server without any additional flags:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl https://localhost:8888/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, the built-in curl client cannot access the mTLS server. We use the &lt;code>-v&lt;/code> option for additional information:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl -v https://localhost:8889/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The output:&lt;/p>
&lt;pre tabindex="0">&lt;code>* Trying [::1]:8889...
* Connected to localhost (::1) port 8889
* ALPN: curl offers h2,http/1.1
* (304) (OUT), TLS handshake, Client hello (1):
* CAfile: /etc/ssl/cert.pem
* CApath: none
* (304) (IN), TLS handshake, Server hello (2):
* (304) (IN), TLS handshake, Unknown (8):
* (304) (IN), TLS handshake, Request CERT (13):
* (304) (IN), TLS handshake, Certificate (11):
* (304) (IN), TLS handshake, CERT verify (15):
* (304) (IN), TLS handshake, Finished (20):
* (304) (OUT), TLS handshake, Certificate (11):
* (304) (OUT), TLS handshake, Finished (20):
* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* ALPN: server accepted http/1.1
* Server certificate:
* subject: C=US; ST=Texas; L=Austin; O=Your Organization; OU=Your Unit; CN=testServerTLS
* start date: Jan 28 17:08:10 2024 GMT
* expire date: Mar 1 17:08:10 2025 GMT
* subjectAltName: host &amp;#34;localhost&amp;#34; matched cert&amp;#39;s &amp;#34;localhost&amp;#34;
* issuer: C=US; ST=Texas; L=Austin; O=Your Organization; OU=Your Unit; CN=testServerCA
* SSL certificate verify ok.
* using HTTP/1.1
&amp;gt; GET /hello-world.txt HTTP/1.1
&amp;gt; Host: localhost:8889
&amp;gt; User-Agent: curl/8.4.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 400 Bad Request
&amp;lt; Server: nginx/1.25.3
&amp;lt; Date: Sun, 28 Jan 2024 18:28:20 GMT
&amp;lt; Content-Type: text/html
&amp;lt; Content-Length: 237
&amp;lt; Connection: close
&amp;lt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;400 No required SSL certificate was sent&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;400 Bad Request&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;center&amp;gt;No required SSL certificate was sent&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.25.3&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
* Closing connection
&lt;/code>&lt;/pre>&lt;p>The client attempted the TLS handshake, but the server rejected the connection because the client did not provide a certificate. Our built-in curl client does not currently support mTLS using the macOS keychain. The client used for this example is:&lt;/p>
&lt;pre tabindex="0">&lt;code>curl 8.4.0 (x86_64-apple-darwin23.0) libcurl/8.4.0 (SecureTransport) LibreSSL/3.3.6 zlib/1.2.12 nghttp2/1.55.1
Release-Date: 2023-10-11
Protocols: dict file ftp ftps gopher gophers http https imap imaps ldap ldaps mqtt pop3 pop3s rtsp smb smbs smtp smtps telnet tftp
Features: alt-svc AsynchDNS GSS-API HSTS HTTP2 HTTPS-proxy IPv6 Kerberos Largefile libz MultiSSL NTLM NTLM_WB SPNEGO SSL threadsafe UnixSockets
&lt;/code>&lt;/pre>&lt;p>On the other hand, Safari can access the mTLS server. We can verify this by opening the following URL in Safari:&lt;/p>
&lt;pre tabindex="0">&lt;code>https://localhost:8889/hello-world.txt
&lt;/code>&lt;/pre>&lt;p>We see the following popup:&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/mtls-with-apple-keychain/mtls-safari.png"
alt="Safari mTLS popup">&lt;figcaption>
&lt;p>Safari mTLS popup&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>We can click &lt;strong>Continue&lt;/strong> to connect to the mTLS server. Future connections will not show the popup and will automatically use the client certificate.&lt;/p>
&lt;p>Google Chrome&amp;rsquo;s behavior is similar.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> If we did not add Safari as an application that can access the client key, Safari would ask for a username and password to connect to the system keychain.&lt;/p>
&lt;h2 id="creating-our-own-mtls-client">&lt;a href="#creating-our-own-mtls-client" class="header-anchor">&lt;/a>Creating our own mTLS client
&lt;/h2>&lt;p>In the following article, we will &lt;a class="link" href="../mtls-go-client" >create our own mTLS client with the Go programming language&lt;/a>. This is the first step toward &lt;a class="link" href="../mtls-go-client-using-apple-keychain" >creating an mTLS client integrated with the macOS keychain&lt;/a>.&lt;/p>
&lt;p>Later, we will &lt;a class="link" href="../mtls-with-windows" >use mTLS with the Windows certificate store&lt;/a> and &lt;a class="link" href="../mtls-go-client-windows-certificate-store" >create an mTLS client integrated with the Windows certificate store&lt;/a>.&lt;/p>
&lt;h2 id="example-code-on-github">&lt;a href="#example-code-on-github" class="header-anchor">&lt;/a>Example code on GitHub
&lt;/h2>&lt;p>The example code is available on GitHub at &lt;a class="link" href="https://github.com/getvictor/mtls/tree/master/mtls-with-apple-keychain" target="_blank" rel="noopener"
>https://github.com/getvictor/mtls/tree/master/mtls-with-apple-keychain&lt;/a>&lt;/p>
&lt;h2 id="mtls-with-macos-keychain-video">&lt;a href="#mtls-with-macos-keychain-video" class="header-anchor">&lt;/a>mTLS with macOS keychain video
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/Y0y6-cCzz8w"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item><item><title>Mutual TLS intro and hands-on example</title><link>https://victoronsoftware.com/posts/mtls-hello-world/</link><pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/mtls-hello-world/</guid><description>&lt;img src="https://victoronsoftware.com/posts/mtls-hello-world/mtls-handshake.png" alt="Featured image of post Mutual TLS intro and hands-on example" />&lt;h2 id="what-is-mtls-mutual-tls">&lt;a href="#what-is-mtls-mutual-tls" class="header-anchor">&lt;/a>What is mTLS (mutual TLS)?
&lt;/h2>&lt;p>TLS stands for Transport Layer Security. It is a cryptographic protocol that provides privacy and data integrity between two communicating applications. It is the successor to SSL (Secure Sockets Layer).&lt;/p>
&lt;p>In ordinary (non-mutual) TLS, the client authenticates the server, but the server does not authenticate the client. Most websites use regular TLS. The client (web browser) knows it is talking to the correct server (website), but the server knows very little about the client. Instead, web applications use other client authentication methods, such as passwords, cookies, and session tokens.&lt;/p>
&lt;p>Mutual TLS (mTLS) is a way to authenticate both the client and the server in a TLS connection. It is also known as client certificate authentication. In addition to the server authenticating itself to the client, the client also authenticates itself to the server.&lt;/p>
&lt;p>mTLS is helpful as an additional layer of security. It is used in many applications, including:&lt;/p>
&lt;ul>
&lt;li>VPNs&lt;/li>
&lt;li>Microservices&lt;/li>
&lt;li>Service mesh&lt;/li>
&lt;li>IoT (Internet of Things)&lt;/li>
&lt;li>Mobile apps&lt;/li>
&lt;/ul>
&lt;h2 id="how-does-fleet-device-managementhttpsfleetdmcom-use-mtls">&lt;a href="#how-does-fleet-device-managementhttpsfleetdmcom-use-mtls" class="header-anchor">&lt;/a>How does &lt;a class="link" href="https://fleetdm.com" target="_blank" rel="noopener"
>Fleet Device Management&lt;/a> use mTLS?
&lt;/h2>&lt;p>Many of Fleet&amp;rsquo;s customers use mTLS as an additional layer of security to authenticate the Fleet server to the Fleet agent. The Fleet agent is a small program that runs on each host device, such as a corporate laptop. It collects information about the host and sends it to the Fleet server.&lt;/p>
&lt;h2 id="how-does-mtls-work">&lt;a href="#how-does-mtls-work" class="header-anchor">&lt;/a>How does mTLS work?
&lt;/h2>&lt;p>TLS is a complex protocol with multiple versions (1.2, 1.3, etc.). We will only go over the basics to understand how mTLS works.&lt;/p>
&lt;p>TLS uses a handshake protocol to establish a secure connection. The handshake protocol is a series of messages between the client and the server.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/mtls-hello-world/mtls-handshake.png"
alt="Mutual TLS (mTLS) handshake diagram">
&lt;/figure>
&lt;p>The client sends a &amp;ldquo;Client Hello&amp;rdquo; message to the server. The server responds with a &amp;ldquo;Server Hello&amp;rdquo; message and sends its certificate to the client. As an additional step for mTLS, the server requests a certificate from the client.&lt;/p>
&lt;p>The client verifies the server&amp;rsquo;s certificate by checking the certificate&amp;rsquo;s signature and verifying that the certificate is valid and has not expired. The client also checks that the server&amp;rsquo;s hostname matches the hostname in the certificate.&lt;/p>
&lt;p>The client uses the server&amp;rsquo;s public key to encrypt the messages sent to the server, including the session key and its certificate. The server decrypts these messages with its private key.&lt;/p>
&lt;p>The client also sends a digital signature, encrypted with its private key, to the server. The server verifies the signature by decrypting it with the client&amp;rsquo;s public key.&lt;/p>
&lt;p>At this point, both the client and the server have verified each other&amp;rsquo;s identity. They complete the TLS handshake and can exchange encrypted messages using a symmetric session key.&lt;/p>
&lt;h2 id="generate-certificates-and-keys">&lt;a href="#generate-certificates-and-keys" class="header-anchor">&lt;/a>Generate certificates and keys
&lt;/h2>&lt;p>We will use the &lt;a class="link" href="https://www.openssl.org/" target="_blank" rel="noopener"
>OpenSSL&lt;/a> command line tool to generate the certificates. OpenSSL is a popular open-source library for TLS and SSL protocols.&lt;/p>
&lt;p>The following script generates the certificates and keys for the client and the server. It also creates two certificate authorities (CAs) and signs the client and server certificates with their respective CA. The same CA may sign the certificates, but we will use separate CAs for this example.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># This script generates files needed for mTLS.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p certs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Private keys for CAs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/server-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl genrsa -out certs/client-ca.key &lt;span style="color:#ae81ff">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate CA certificates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/server-ca.key -out certs/server-ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -new -x509 -nodes -days &lt;span style="color:#ae81ff">1000&lt;/span> -key certs/client-ca.key -out certs/client-ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Generate a certificate signing request&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa:2048 -nodes -keyout certs/server.key -out certs/server.req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl req -newkey rsa:2048 -nodes -keyout certs/client.key -out certs/client.req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Have the CA sign the certificate requests and output the certificates.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/server.req -days &lt;span style="color:#ae81ff">1000&lt;/span> -CA certs/server-ca.crt -CAkey certs/server-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/server.crt -extfile localhost.ext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openssl x509 -req -in certs/client.req -days &lt;span style="color:#ae81ff">1000&lt;/span> -CA certs/client-ca.crt -CAkey certs/client-ca.key -set_serial &lt;span style="color:#ae81ff">01&lt;/span> -out certs/client.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Clean up&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm certs/server.req
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm certs/client.req
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>localhost.ext&lt;/code> file is used to specify the hostname for the server certificate. In our example, we will use &lt;code>localhost&lt;/code>. The file contains the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = localhost
&lt;/code>&lt;/pre>&lt;h2 id="run-the-mtls-server">&lt;a href="#run-the-mtls-server" class="header-anchor">&lt;/a>Run the mTLS server
&lt;/h2>&lt;p>We will use &lt;a class="link" href="https://www.nginx.com/" target="_blank" rel="noopener"
>nginx&lt;/a> as our mTLS server. nginx is a popular open-source web server.&lt;/p>
&lt;p>Using &lt;code>docker compose&lt;/code>, we can run two nginx servers. One server will use ordinary TLS, and one will use mutual TLS. We will use the following &lt;code>docker-compose.yml&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx-tls&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./certs/server.crt:/etc/nginx/certificates/server.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./certs/server.key:/etc/nginx/certificates/server.key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./nginx-tls/nginx.conf:/etc/nginx/conf.d/default.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./nginx-tls/hello-world.txt:/www/data/hello-world.txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;8888:8888&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx-mtls&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./certs/server.crt:/etc/nginx/certificates/server.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./certs/server.key:/etc/nginx/certificates/server.key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./certs/client-ca.crt:/etc/nginx/certificates/client-ca.crt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./nginx-mtls/nginx.conf:/etc/nginx/conf.d/default.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./nginx-mtls/hello-world.txt:/www/data/hello-world.txt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;8889:8889&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>nginx-tls&lt;/code> service uses the &lt;code>nginx-tls/nginx.conf&lt;/code> file, which contains the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>server {
listen 8888 ssl;
server_name tls-hello-world;
# Server TLS certificate (client must have the CA cert to connect)
ssl_certificate /etc/nginx/certificates/server.crt;
ssl_certificate_key /etc/nginx/certificates/server.key;
location / {
root /www/data;
}
}
&lt;/code>&lt;/pre>&lt;p>The &lt;code>nginx-mtls&lt;/code> service uses the &lt;code>nginx-mtls/nginx.conf&lt;/code> file, which contains the following:&lt;/p>
&lt;pre tabindex="0">&lt;code>server {
listen 8889 ssl;
server_name mtls-hello-world;
# Server TLS certificate (client must have the CA cert to connect)
ssl_certificate /etc/nginx/certificates/server.crt;
ssl_certificate_key /etc/nginx/certificates/server.key;
# Enable mTLS
ssl_client_certificate /etc/nginx/certificates/client-ca.crt;
ssl_verify_client on;
location / {
root /www/data;
}
}
&lt;/code>&lt;/pre>&lt;p>The &lt;code>hello-world.txt&lt;/code> files contain a simple text message.&lt;/p>
&lt;h2 id="connect-to-the-mtls-server-with-curl-client">&lt;a href="#connect-to-the-mtls-server-with-curl-client" class="header-anchor">&lt;/a>Connect to the mTLS server with curl client
&lt;/h2>&lt;p>We can connect to the mTLS server with the &lt;code>curl&lt;/code> command line tool. We will use the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl https://localhost:8889/hello-world.txt --cacert ./certs/server-ca.crt --cert ./certs/client.crt --key ./certs/client.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>--cacert&lt;/code> option specifies the CA certificate that signed the server certificate. The &lt;code>--cert&lt;/code> and &lt;code>--key&lt;/code> options select the client certificate and key.&lt;/p>
&lt;p>To connect to the ordinary TLS server, we do not need to specify the client certificate and key:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl https://localhost:8888/hello-world.txt --cacert ./certs/server-ca.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Curl can use &lt;code>--insecure&lt;/code> to ignore the server certificate:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl --insecure https://localhost:8888/hello-world.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, it is impossible to ignore the client certificate for mTLS. The server will reject the connection if the client does not provide a valid certificate.&lt;/p>
&lt;h2 id="example-code-on-github">&lt;a href="#example-code-on-github" class="header-anchor">&lt;/a>Example code on GitHub
&lt;/h2>&lt;p>The example code is available on GitHub at &lt;a class="link" href="https://github.com/getvictor/mtls/tree/master/hello-world" target="_blank" rel="noopener"
>https://github.com/getvictor/mtls/tree/master/hello-world&lt;/a>&lt;/p>
&lt;h2 id="securing-mtls-certificates-and-keys">&lt;a href="#securing-mtls-certificates-and-keys" class="header-anchor">&lt;/a>Securing mTLS certificates and keys
&lt;/h2>&lt;p>In the next article, we will &lt;a class="link" href="../mtls-with-apple-keychain" >secure the mTLS certificates and keys with the macOS keychain&lt;/a>.&lt;/p>
&lt;p>In a later article, we also &lt;a class="link" href="../mtls-with-windows" >secure the mTLS certificates and keys with the Windows certificate store&lt;/a>.&lt;/p>
&lt;p>This article is part of a series on &lt;a class="link" href="../mtls" >mTLS&lt;/a>.&lt;/p>
&lt;h2 id="mtls-hello-world-video">&lt;a href="#mtls-hello-world-video" class="header-anchor">&lt;/a>mTLS Hello World video
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/WA_RL_QtIgY"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>Note:&lt;/em> If you want to comment on this article, please do so on the YouTube video.&lt;/p></description></item><item><title>Understanding the intricacies of Fleet policies</title><link>https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/</link><pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/</guid><description>&lt;img src="https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/understanding-the-intricacies-of-fleet-policies-main-policies-page-1999x978@2x.png" alt="Featured image of post Understanding the intricacies of Fleet policies" />&lt;p>In the ever-evolving landscape of device management and cybersecurity, understanding the mechanics behind tools like Fleet is not just about technical curiosity; it&amp;rsquo;s about empowering IT professionals to safeguard digital assets more effectively. &lt;a class="link" href="https://fleetdm.com" target="_blank" rel="noopener"
>Fleet&lt;/a> gathers telemetry from various devices, from laptops to virtual machines, using &lt;a class="link" href="https://www.osquery.io/" target="_blank" rel="noopener"
>osquery&lt;/a>. At the heart of this system lies a crucial feature: &lt;a class="link" href="https://fleetdm.com/securing/what-are-fleet-policies" target="_blank" rel="noopener"
>Fleet policies&lt;/a>.&lt;/p>
&lt;p>Policies in Fleet are more than just rules; they are the gatekeepers of your device&amp;rsquo;s security, ensuring stringent adherence to security standards. By dissecting how Fleet policies operate &amp;ldquo;under the hood,&amp;rdquo; IT administrators and security professionals can gain invaluable insights. These insights allow for setting up efficient security protocols and rapid response to potential vulnerabilities, a necessity in a landscape where cyber threats are constantly evolving. This article delves into the inner workings of Fleet policies, providing you with the knowledge to better configure, manage, and leverage these policies for optimal device security and efficiency.&lt;/p>
&lt;h2 id="policy-creation">&lt;a href="#policy-creation" class="header-anchor">&lt;/a>Policy creation
&lt;/h2>&lt;p>Policies can be created from the web UI, the command-line interface called &lt;code>fleetctl&lt;/code> with config files, or the REST API. The user creates a policy and selects which devices need to be checked using that policy. Policies can be global or team-specific.&lt;/p>
&lt;p>When a policy is created, a record for it is stored in the &lt;strong>policies&lt;/strong> table of the MySQL database. A Fleet deployment consists of several servers behind a load balancer, so storing the record in the DB makes all servers aware of the new policy.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/understanding-the-intricacies-of-fleet-policies-policy-creation-1280x720@2x.png"
alt="Fleet policies block diagram">
&lt;/figure>
&lt;h2 id="policy-execution">&lt;a href="#policy-execution" class="header-anchor">&lt;/a>Policy execution
&lt;/h2>&lt;p>Policies are executed on the devices, which are called &lt;strong>hosts&lt;/strong> in Fleet, according to the &lt;a class="link" href="https://fleetdm.com/docs/configuration/fleet-server-configuration#osquery-policy-update-interval" target="_blank" rel="noopener"
>FLEET_OSQUERY_POLICY_UPDATE_INTERVAL&lt;/a>, which is set to 1 hour by default. This interval can be adjusted with the environment variable or set from the server’s command line.&lt;/p>
&lt;p>Policies are simply SQL queries that return a true or false result, so the flow they use on the hosts is the same as other queries. Hosts check in with Fleet servers every 10 seconds (the default) and access the &lt;code>/api/v1/osquery/distributed/read&lt;/code> API endpoint. The server checks when the policy was last executed to determine whether it should be executed again. If so, the server adds the policy to its response. For example, this policy in the server response checks if the macOS firewall is enabled:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;queries&amp;#34;: {
&amp;#34;fleet_policy_query_9&amp;#34;: &amp;#34;SELECT 1 FROM alf WHERE global_state &amp;gt;= 1;&amp;#34;
},
&amp;#34;discovery&amp;#34;: {
&amp;#34;fleet_policy_query_9&amp;#34;: &amp;#34;SELECT 1&amp;#34;
}
}
&lt;/code>&lt;/pre>&lt;p>Once the host has executed the policy, it writes the result to the server. The server updates the result in the &lt;strong>policy_membership&lt;/strong> table of the MySQL database. At this point, the Host Details page on the web UI is updated with the policy result.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/understanding-the-intricacies-of-fleet-policies-host-policy-view-1818x1999@2x.png"
alt="Fleet policies on host details page">
&lt;/figure>
&lt;h2 id="force-policy-execution-on-a-device">&lt;a href="#force-policy-execution-on-a-device" class="header-anchor">&lt;/a>Force policy execution on a device
&lt;/h2>&lt;p>The user can force the host to execute all of its policies by clicking the &lt;strong>Refetch&lt;/strong> link:&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/understanding-the-intricacies-of-fleet-policies-refetch-204x64@2x.png"
alt="Fleet refetch host details">
&lt;/figure>
&lt;h2 id="policy-results-aggregation">&lt;a href="#policy-results-aggregation" class="header-anchor">&lt;/a>Policy results aggregation
&lt;/h2>&lt;p>However, the main &lt;strong>Policies&lt;/strong> page is not updated. This page shows the counts of all passing and failing hosts for each policy. A worker process on one of the Fleet servers updates it once an hour. The worker calculates the counts and stores them in the &lt;strong>policy_stats&lt;/strong> table in the database. This is done for better performance of the UI. For customers with 100,000s of hosts that asynchronously report their policy results, calculating the passing and failing counts in real time was noticeably slow.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/understanding-the-intricacies-of-fleet-policies/understanding-the-intricacies-of-fleet-policies-main-policies-page-1999x978@2x.png"
alt="Fleet policies page">
&lt;/figure>
&lt;h2 id="summary">&lt;a href="#summary" class="header-anchor">&lt;/a>Summary
&lt;/h2>&lt;p>Understanding the intricacies of Fleet policies is essential for IT professionals managing a fleet of devices. This deep dive into the mechanics of Fleet policies — from creation to execution — provides you with the necessary insights to optimize your cybersecurity strategy effectively. By leveraging these policies, you can ensure stringent security standards across your network, enhancing your organization&amp;rsquo;s digital defense. As the cyber landscape evolves, tools like Fleet remain crucial in maintaining robust and responsive security protocols. We encourage you to apply these insights in your Fleet usage, and as always, we welcome your feedback and experiences in the &lt;a class="link" href="https://fleetdm.com/support" target="_blank" rel="noopener"
>Fleet community Slack channels&lt;/a>.&lt;/p>
&lt;h2 id="understanding-the-intricacies-of-fleet-policies-video">&lt;a href="#understanding-the-intricacies-of-fleet-policies-video" class="header-anchor">&lt;/a>Understanding the intricacies of Fleet policies video
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/A-Qapp7vYJk"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;em>This article originally appeared in &lt;a class="link" href="https://fleetdm.com/guides/understanding-the-intricacies-of-fleet-policies" target="_blank" rel="noopener"
>Fleet&amp;rsquo;s blog&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>Get current telemetry from your devices with live queries</title><link>https://victoronsoftware.com/posts/get-current-telemetry-from-your-devices-with-live-queries/</link><pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/get-current-telemetry-from-your-devices-with-live-queries/</guid><description>&lt;img src="https://victoronsoftware.com/posts/get-current-telemetry-from-your-devices-with-live-queries/Live%20Query.png" alt="Featured image of post Get current telemetry from your devices with live queries" />&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/Jh14hNjW0Uo"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;a class="link" href="https://fleetdm.com/" target="_blank" rel="noopener"
>Fleet&lt;/a> is an open-source platform for managing and gathering telemetry from devices such as laptops, desktops, VMs, etc. &lt;a class="link" href="https://www.osquery.io/" target="_blank" rel="noopener"
>Osquery&lt;/a> agents run on these devices and report to the Fleet server. One of Fleet’s features is the ability to query information from the devices in near real-time, called &lt;em>live queries&lt;/em>. This article discusses how live queries work “under the hood.”&lt;/p>
&lt;h2 id="why-a-live-query">&lt;a href="#why-a-live-query" class="header-anchor">&lt;/a>Why a live query?
&lt;/h2>&lt;p>Live queries enable administrators to ask near real-time questions of all online devices, such as checking the encryption status of SSH keys across endpoints, or obtaining the uptime of each server within their purview. This enables them to promptly identify and address any issues, thereby reducing downtime and maintaining operational efficiency. These tasks, which would be time-consuming and complex if done manually, are streamlined through live queries, offering real-time insights into the status and posture of the entire fleet of devices helping IT and security.&lt;/p>
&lt;h2 id="live-queries-under-the-hood">&lt;a href="#live-queries-under-the-hood" class="header-anchor">&lt;/a>Live queries under the hood
&lt;/h2>&lt;p>Live queries can be run from the web UI, the command-line interface called &lt;code>fleetctl&lt;/code>, or the REST API. The user creates a query and selects which devices will run that query. Here is an example using &lt;code>fleetctl&lt;/code> to obtain the operating system name and version for all devices:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>fleetctl query --query &lt;span style="color:#e6db74">&amp;#34;select name, version from os_version;&amp;#34;&lt;/span> --labels &lt;span style="color:#e6db74">&amp;#34;All Hosts&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When a client initiates a live query, the server first creates a &lt;strong>Query Campaign&lt;/strong> record in the MySQL database. A Fleet deployment consists of several servers behind a load balancer, so storing the record in the DB makes all servers aware of the new query campaign.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/get-current-telemetry-from-your-devices-with-live-queries/Live%20Query.png"
alt="Query campaign">&lt;figcaption>
&lt;h4>Query campaign&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>As devices called &lt;strong>Hosts&lt;/strong> in Fleet check in with the servers, they receive instructions to run a query. For example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;queries&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fleet_distributed_query_140&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SELECT name, version FROM os_version;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;discovery&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fleet_distributed_query_140&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SELECT 1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, the osquery agents run the actual query on their host, and write the result back to a Fleet server. As a server receives the result, it publishes it to the common cache using &lt;a class="link" href="https://redis.io/docs/interact/pubsub/" target="_blank" rel="noopener"
>Redis Pub/Sub&lt;/a>.&lt;/p>
&lt;p>Only the one server communicating with the client subscribes to the results. It processes the data from the cache, keeps track of how many hosts reported back, and communicates results back to the client. The web UI and &lt;code>fleetctl&lt;/code> interfaces use a &lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener"
>WebSockets API&lt;/a>, and results are reported as they come in. The REST API, on the other hand, only sends a response after all online hosts have reported their query results.&lt;/p>
&lt;h2 id="discover-more">&lt;a href="#discover-more" class="header-anchor">&lt;/a>Discover more
&lt;/h2>&lt;p>Fleet’s live query feature represents a powerful tool in the arsenal of IT and security administrators. By harnessing the capabilities of live queries, tasks that once required extensive manual effort can now be executed swiftly and efficiently. This real-time querying ability enhances operational efficiency and significantly bolsters security and compliance measures across a range of devices.&lt;/p>
&lt;p>The integration of Fleet with Osquery agents, the flexibility offered by interfaces like the web UI, &lt;code>fleetctl&lt;/code>, and the REST API, and the efficient data handling through mechanisms like Redis Pub/Sub and WebSockets API all come together to create a robust, real-time telemetry gathering system. This system is designed to keep you informed about the current state of your device fleet, helping you make informed decisions quickly.&lt;/p>
&lt;p>As you reflect on the capabilities of live queries with Fleet, consider your network environment&amp;rsquo;s unique challenges and needs. &lt;strong>What questions could live queries help you answer about your devices?&lt;/strong> Whether it&amp;rsquo;s security audits, performance monitoring, or compliance checks, live queries offer a dynamic solution to address these concerns.&lt;/p>
&lt;p>We encourage you to explore the possibilities and share your thoughts or questions. Perhaps you’re facing a specific query challenge or an innovative use case you’ve discovered. Whatever it may be, the world of live queries is vast and ripe for exploration. Join us in &lt;a class="link" href="https://fleetdm.com/support" target="_blank" rel="noopener"
>Fleet’s Slack forums&lt;/a> to engage with a community of like-minded professionals and deepen your understanding of what live queries can achieve in your environment.&lt;/p>
&lt;p>API Documentation:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://fleetdm.com/docs/rest-api/rest-api#run-live-query" target="_blank" rel="noopener"
>Run live query with REST API&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/fleetdm/fleet/blob/6fd06d648601edd89c01e25426e2e35ff2a8a37b/docs/Contributing/API-for-contributors.md#run-live-query" target="_blank" rel="noopener"
>Run live query with WebSockets&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;em>This article originally appeared in &lt;a class="link" href="https://fleetdm.com/guides/get-current-telemetry-from-your-devices-with-live-queries" target="_blank" rel="noopener"
>Fleet&amp;rsquo;s blog&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>Physical security meets cybersecurity with Matter</title><link>https://victoronsoftware.com/posts/physical-security-meets-cybersecurity-with-matter/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/physical-security-meets-cybersecurity-with-matter/</guid><description>&lt;img src="https://victoronsoftware.com/posts/physical-security-meets-cybersecurity-with-matter/cover.png" alt="Featured image of post Physical security meets cybersecurity with Matter" />&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/mIVsLTrUork"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>Matter is a recent open-source standard for connecting devices such as light switches, door locks,
motion sensors, and many others. The major goals of the standard are compatibility and
interoperability. This means that you will no longer need to be an expert hacker when trying to
control devices from multiple manufacturers under a single application. Apple, Amazon, and Google
are some of the major members driving the standard. This is great news for the majority of adopters
who haven’t yet fully embraced home automation and security.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/physical-security-meets-cybersecurity-with-matter/matter.jpeg">
&lt;/figure>
&lt;p>The Matter specification is published by
the &lt;a class="link" href="https://csa-iot.org/" target="_blank" rel="noopener"
>Connectivity Standards Alliance&lt;/a> (CSA) and includes a
&lt;a class="link" href="https://github.com/project-chip/connectedhomeip" target="_blank" rel="noopener"
>software development kit&lt;/a>. Version 1.0 of the
specification was released in October of 2022. In 2023,
we saw a slew of new devices and software upgrades compatible with Matter. Version 1.2 of the
specification was published in October of 2023. However, this latest specification is still missing
support for a few important device categories such as cameras and major appliances. Cameras are a
top priority for the CSA, and we may see Matter-compatible cameras in 2024.&lt;/p>
&lt;p>Matter is an important step for the management of IoT devices because it finally brings true
interoperability where it has been sorely missing for so many years. No longer will device
manufacturers need to decide and budget precious software resources to support Amazon Alexa, Google
Home, Apple HomeKit, or another connectivity hub. Customers will no longer be locked into using one
of the major home automation providers. And home automation solutions from smaller companies will
come onto the market.&lt;/p>
&lt;p>An important feature of Matter is &lt;strong>multi-admin&lt;/strong>, which means that devices can be read and
controlled by multiple clients. In Matter terminology, the device, such as a motion sensor, is
called a server or node, and the applications controlling it are called clients. For example, a
light switch may be simultaneously controlled by the manufacturer’s app, by Alexa, and by the user&amp;rsquo;s
hand-written custom API client.&lt;/p>
&lt;p>Multi-admin support means that a home or business may use one application to control their locks,
switches, and security sensors, and another application for reading telemetry from those same
devices. Businesses will find it easier to integrate physical security with cyber security. For
example, suppose a business’s device management server uses Matter to subscribe to the office door
lock. It receives an alert that &lt;em>User A&lt;/em> has entered their code. Afterwards, via regular scheduled
telemetry, it notices a successful login to &lt;em>Computer B&lt;/em>. The business SIEM (security information and
event management) system should immediately flag this suspicious sequence of events.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/physical-security-meets-cybersecurity-with-matter/cover.png"
alt="Physical security with Matter">
&lt;/figure>
&lt;p>Of course, the example above can be accomplished today by writing some custom code or using a third party integration. What Matter brings is scalability to such security approaches. The code and integration will no longer need to be redone for each new device and version that comes onto the market.&lt;/p></description></item><item><title>Setting up a virtual router (pfSense on Proxmox)</title><link>https://victoronsoftware.com/posts/setting-up-a-virtual-router/</link><pubDate>Wed, 22 Nov 2023 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/setting-up-a-virtual-router/</guid><description>&lt;img src="https://victoronsoftware.com/posts/setting-up-a-virtual-router/cover.jpeg" alt="Featured image of post Setting up a virtual router (pfSense on Proxmox)" />&lt;p>Traditionally, network routers used dedicated bare metal machines. However, in the last several
years, we’ve seen a rise in software-based routers that can be deployed either on bare metal, on a
VM, or even on a container. This means these virtual routers can be used to replace existing router
software on an older router. They can run in the cloud. Or they can be installed on do-it-yourself
(DIY) hardware. A couple popular open source software-based routers
are &lt;a class="link" href="https://www.pfsense.org/" target="_blank" rel="noopener"
>pfSense&lt;/a> and &lt;a class="link" href="https://opnsense.org/" target="_blank" rel="noopener"
>OPNsense&lt;/a>.&lt;/p>
&lt;h2 id="why-use-a-virtual-router">&lt;a href="#why-use-a-virtual-router" class="header-anchor">&lt;/a>Why use a virtual router?
&lt;/h2>&lt;p>For one, these routers offer enterprise-level features such as build-in VPN support, traffic
analysis, and extensive diagnostics, among others. Another reason is that having a virtual router
gives you the ability to experiment &amp;ndash; you can install multiple routers on top of your hypervisor,
and try all of them out. A third reason is that the virtual router may be only one of many VMs that
you run on your hardware. You can use the same piece of hardware to run a router, an ad-blocking
service, a media server, and other applications.&lt;/p>
&lt;h2 id="advanced-virtual-router-installation-and-set-up">&lt;a href="#advanced-virtual-router-installation-and-set-up" class="header-anchor">&lt;/a>Advanced virtual router installation and set up
&lt;/h2>&lt;p>When setting up our virtual router, we chose to
use &lt;a class="link" href="https://pve.proxmox.com/wiki/PCI%28e%29_Passthrough" target="_blank" rel="noopener"
>PCI Passthrough&lt;/a> to allow the virtual router
direct access to the NIC hardware. Direct access to hardware improves the latency of our internet
traffic. In addition, we wanted our hypervisor to sit behind the router, and not be exposed to the
public. This reduces the attack surface for potential bad agents. However, routing hypervisor
traffic through the router made our setup a bit tricker. It is like the chicken or the egg
dilemma &amp;ndash; how do you put your hypervisor behind the router when the hypervisor is responsible for
managing the router? Below is the approach we used when installing pfSense on top
of &lt;a class="link" href="https://www.proxmox.com/en/proxmox-virtual-environment/overview" target="_blank" rel="noopener"
>Proxmox Virtual
Environment (PVE)&lt;/a>.&lt;/p>
&lt;p>For the initial installation, we did not use PCI Passthrough and instead used a virtual network
bridge (&lt;strong>vmbr0&lt;/strong>). We configured the router VM to start on boot.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/setting-up-a-virtual-router/Virtual-Router-1.jpg"
alt="Initial virtual router configuration">&lt;figcaption>
&lt;h4>Initial virtual router configuration&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>This allowed us to continue controlling the virtual router through the PVE web GUI. We set up the
router and enabled access to it through the serial interface, which we used in the next step. Then,
we put the system into its final configuration.&lt;/p>
&lt;figure>&lt;img src="https://victoronsoftware.com/posts/setting-up-a-virtual-router/Virtual-Router-2.jpg"
alt="Final virtual router configuration">&lt;figcaption>
&lt;h4>Final virtual router configuration&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>In order to finish configuring, we had to plug in a monitor and keyboard into our hardware. We
accessed the virtual router via the serial interface from the PVE command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>qm terminal &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We updated the WAN interface to use &lt;strong>eth0&lt;/strong>. At this point, the LAN interface &lt;strong>eth1&lt;/strong> had access
to the internet.&lt;/p>
&lt;p>In addition, we added a second LAN interface for the network bridge (&lt;strong>vmbr0&lt;/strong>). We made sure
firewall configurations for both LAN interfaces were the same.&lt;/p>
&lt;p>Next, from the PVE command line, we updated the PVE IP and gateway to point at the router by
modifying the following files.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>/etc/network/interfaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/etc/hosts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>After rebooting PVE, we had access to the internet and to the PVE Web GUI from our new LAN.&lt;/p>
&lt;h2 id="updating-router-software">&lt;a href="#updating-router-software" class="header-anchor">&lt;/a>Updating router software
&lt;/h2>&lt;p>Using a virtual router with PCI Passthrough creates a unique challenge when doing software updates.
What if the new version doesn’t work? What if you lose all internet access.&lt;/p>
&lt;p>We can mitigate potential issues. First, we recommend always making a backup of the router VM when
upgrading. That way we can easily roll back the change. Switching to a backup, however, requires
keyboard and monitor access to your hardware, since it must be done via the PVE command line.&lt;/p>
&lt;p>Another way to safely upgrade is to spin up a second VM running updated router software. The second
VM can be either from a backup or brand new. This VM should use virtual network bridges for its
connections. Once it is properly configured, we can stop the first router VM and switch the port
connections to the second VM. This flow also requires accessing the router via the serial interface
to update the WAN/LAN interfaces.&lt;/p>
&lt;h2 id="setting-up-a-virtual-router-video">&lt;a href="#setting-up-a-virtual-router-video" class="header-anchor">&lt;/a>Setting up a virtual router video
&lt;/h2>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/uj_lB__QDTc"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div></description></item><item><title>Inspecting keychain files on macOS</title><link>https://victoronsoftware.com/posts/inspecting-keychain-files-on-macos/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://victoronsoftware.com/posts/inspecting-keychain-files-on-macos/</guid><description>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/QBn_C2nl2ZE"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>Keychains are the macOS’s method to track and protect secure information such as passwords, private keys, and certificates. Traditionally, the keychain information was stored in files, such as:&lt;/p>
&lt;pre tabindex="0">&lt;code>/Library/Keychains/System.keychain
/Library/Keychains/apsd.keychain
/System/Library/Keychains/SystemRootCertificates.keychain
/Users/&amp;lt;username&amp;gt;/Library/Keychains/login.keychain-db
&lt;/code>&lt;/pre>&lt;p>In the last several years, Apple also introduced data protection keychains, such as the iCloud
Keychain. Although the file-based keychains above are on the road to deprecation in favor of data
protection keychains, current macOS systems still heavily rely on them. It is unclear when, if
ever, these keychains will be replaced by data protection keychains.&lt;/p>
&lt;p>Inspecting file-based keychains has gotten more difficult as Apple deprecated many of the APIs
associated with them, such as &lt;a class="link" href="https://developer.apple.com/documentation/security/1396431-seckeychainopen" target="_blank" rel="noopener"
>SecKeychainOpen&lt;/a>.
In addition, excessive use of these deprecated APIs may result in corruption of the Login Keychain,
as mentioned in this &lt;a class="link" href="https://github.com/osquery/osquery/issues/7780" target="_blank" rel="noopener"
>osquery issue&lt;/a>.
By NOT using the deprecated APIs, the user only has access to the following keychains from the above list:&lt;/p>
&lt;pre tabindex="0">&lt;code>/Library/Keychains/System.keychain
/Users/&amp;lt;username&amp;gt;/Library/Keychains/login.keychain-db
&lt;/code>&lt;/pre>&lt;p>Root certificates are missing. And the APSD (Apple Push Service Daemon) keychain is missing, which is used for device management, among other things.&lt;/p>
&lt;p>So, how can app developers and IT professionals continue to have access to ALL of these keychain files?&lt;/p>
&lt;p>One way is to continue using deprecated APIs until they stop working. We recommend making a secure copy of the keychain files before accessing them with the APIs.&lt;/p>
&lt;p>Another option is to use the macOS &lt;a class="link" href="https://ss64.com/osx/security.html" target="_blank" rel="noopener"
>security&lt;/a> command line tool. For example, to list root certificates, do the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo security find-certificate -a /System/Library/Keychains/SystemRootCertificates.keychain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A third, and hardest, option is to parse the &lt;a class="link" href="https://github.com/libyal/dtformats/blob/main/documentation/MacOS%20keychain%20database%20file%20format.asciidoc" target="_blank" rel="noopener"
>keychain files&lt;/a> yourself. Some details on the keychain format are available. Please leave a comment if you or someone else has created a tool to parse Apple keychains.&lt;/p>
&lt;p>The fourth option is to use an existing tool, such as &lt;a class="link" href="https://www.osquery.io/" target="_blank" rel="noopener"
>osquery&lt;/a>. Osquery is an open-source tool built for security and IT professionals. Osquery developers are working on fixing any issues to continue providing access to macOS keychain files via the following tables:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://fleetdm.com/tables/certificates" target="_blank" rel="noopener"
>certificates&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://fleetdm.com/tables/keychain_acls" target="_blank" rel="noopener"
>keychain_acls&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://fleetdm.com/tables/keychain_items" target="_blank" rel="noopener"
>keychain_items&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>